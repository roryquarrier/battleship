<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battleship ESL - Naval Combat Grammar Challenge</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { height: 100%; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
// ============================================
// BATTLESHIP ESL - VERSION 9.3 (ROBUST CONNECTION)
// ============================================

const grammarQuestions = {
  easy: [
    { q: "I ___ a student.", options: ["am", "is", "are", "be"], answer: 0 },
    { q: "She ___ to school every day.", options: ["go", "goes", "going", "went"], answer: 1 },
    { q: "They ___ playing football.", options: ["is", "am", "are", "be"], answer: 2 },
    { q: "This is ___ apple.", options: ["a", "an", "the", "some"], answer: 1 },
    { q: "He ___ a dog.", options: ["have", "has", "having", "had"], answer: 1 },
    { q: "We ___ happy today.", options: ["is", "am", "are", "be"], answer: 2 },
    { q: "The cat is ___ the table.", options: ["in", "on", "at", "to"], answer: 1 },
    { q: "I like ___ ice cream.", options: ["eat", "eating", "ate", "eats"], answer: 1 },
    { q: "___ is your name?", options: ["Who", "What", "Where", "When"], answer: 1 },
    { q: "She ___ not like vegetables.", options: ["do", "does", "is", "are"], answer: 1 },
    { q: "There ___ two birds.", options: ["is", "are", "am", "be"], answer: 1 },
    { q: "My mother ___ cooking.", options: ["is", "are", "am", "be"], answer: 0 },
    { q: "I can ___ a bike.", options: ["ride", "rides", "riding", "rode"], answer: 0 },
    { q: "The sun ___ bright.", options: ["is", "are", "am", "be"], answer: 0 },
    { q: "We go to school ___ Monday.", options: ["in", "on", "at", "to"], answer: 1 }
  ],
  medium: [
    { q: "She ___ finished her homework.", options: ["have", "has", "had", "having"], answer: 1 },
    { q: "If it rains, I ___ stay home.", options: ["will", "would", "can", "could"], answer: 0 },
    { q: "The movie was ___ than I expected.", options: ["good", "better", "best", "more good"], answer: 1 },
    { q: "He asked me ___ I was going.", options: ["where", "what", "which", "who"], answer: 0 },
    { q: "I wish I ___ fly.", options: ["can", "could", "will", "would"], answer: 1 },
    { q: "She ___ studying when I called.", options: ["is", "was", "were", "been"], answer: 1 },
    { q: "Neither Tom ___ Jerry came.", options: ["or", "nor", "and", "but"], answer: 1 },
    { q: "This is the ___ day of my life!", options: ["happy", "happier", "happiest", "more happy"], answer: 2 },
    { q: "I have been waiting ___ two hours.", options: ["since", "for", "from", "during"], answer: 1 },
    { q: "The book ___ by Shakespeare.", options: ["wrote", "written", "was written", "is writing"], answer: 2 }
  ],
  hard: [
    { q: "Had I known, I ___ differently.", options: ["would act", "would have acted", "will act", "acted"], answer: 1 },
    { q: "Not only ___ late, but he also forgot.", options: ["he was", "was he", "he is", "is he"], answer: 1 },
    { q: "The report ___ by tomorrow.", options: ["will finish", "will be finished", "finishes", "is finishing"], answer: 1 },
    { q: "Scarcely had I arrived ___ it started raining.", options: ["than", "when", "then", "that"], answer: 1 },
    { q: "It's high time you ___ a decision.", options: ["make", "made", "making", "to make"], answer: 1 },
    { q: "Were it not for his help, I ___.", options: ["would fail", "would have failed", "will fail", "failed"], answer: 1 },
    { q: "The more you practice, ___.", options: ["better you get", "the better you get", "you get better", "best you get"], answer: 1 },
    { q: "I wish he ___ here yesterday.", options: ["was", "were", "had been", "has been"], answer: 2 },
    { q: "No sooner had she left ___ the phone rang.", options: ["when", "than", "then", "that"], answer: 1 },
    { q: "Little ___ that he would win.", options: ["he knew", "did he know", "he did know", "knew he"], answer: 1 }
  ]
};

const GRID_SIZE = 10;
const SHIPS = [
  { name: 'Carrier', size: 5, color: '#e74c3c' },
  { name: 'Battleship', size: 4, color: '#9b59b6' },
  { name: 'Cruiser', size: 3, color: '#3498db' },
  { name: 'Submarine', size: 3, color: '#1abc9c' },
  { name: 'Destroyer', size: 2, color: '#f39c12' }
];

const WEAPONS = {
  simple: { name: 'Standard Shot', pattern: [[0, 0]], icon: 'üéØ' },
  big: { name: 'Big Bomb', pattern: [[0,0],[-1,0],[1,0],[0,-1],[0,1]], icon: 'üí£' },
  rain: { name: 'Missile Rain', pattern: 'random', icon: 'üåßÔ∏è' },
  nuclear: { name: 'Nuclear Strike', pattern: [[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[0,1],[1,-1],[1,0],[1,1]], icon: '‚ò¢Ô∏è' }
};

const createEmptyGrid = () => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
const getRandomQuestion = (difficulty) => {
  const questions = grammarQuestions[difficulty];
  return questions[Math.floor(Math.random() * questions.length)];
};
const generateRainPattern = () => {
  const pattern = [];
  const used = new Set();
  while (pattern.length < 7) {
    const x = Math.floor(Math.random() * 5) - 2;
    const y = Math.floor(Math.random() * 5) - 2;
    const key = `${x},${y}`;
    if (!used.has(key)) { used.add(key); pattern.push([x, y]); }
  }
  return pattern;
};

function BattleshipESL() {
  const { useState, useEffect, useCallback, useRef } = React;

  const [gameMode, setGameMode] = useState(null);
  const [gamePhase, setGamePhase] = useState('menu');
  const [difficulty, setDifficulty] = useState('medium');
  const [winner, setWinner] = useState(null);

  const [player1, setPlayer1] = useState({
    grid: createEmptyGrid(), ships: [], tracking: createEmptyGrid(), received: createEmptyGrid(),
    weapons: { simple: Infinity, big: 0, rain: 0, nuclear: 0 }, gifts: [], shipsRemaining: 5
  });
  const [player2, setPlayer2] = useState({
    grid: createEmptyGrid(), ships: [], tracking: createEmptyGrid(), received: createEmptyGrid(),
    weapons: { simple: Infinity, big: 0, rain: 0, nuclear: 0 }, gifts: [], shipsRemaining: 5
  });

  const [opponentSetupReceived, setOpponentSetupReceived] = useState(false);
  const [currentShipIndex, setCurrentShipIndex] = useState(0);
  const [isHorizontal, setIsHorizontal] = useState(true);
  const [placedShips, setPlacedShips] = useState([]);
  const [selectedWeapon, setSelectedWeapon] = useState('simple');
  const [shotResults, setShotResults] = useState([]);
  const [extraTurn, setExtraTurn] = useState(false);
  const [sunkShip, setSunkShip] = useState(null);
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [answerResult, setAnswerResult] = useState(null);
  const [isWatchingQuestion, setIsWatchingQuestion] = useState(false);

  // Connection state - simplified and explicit
  const [myPeerId, setMyPeerId] = useState('');
  const [hostCode, setHostCode] = useState('');
  const [peerReady, setPeerReady] = useState(false);
  const [connected, setConnected] = useState(false);
  const [statusMsg, setStatusMsg] = useState('');
  const [isMyTurn, setIsMyTurn] = useState(false);
  const [waitingForOpponent, setWaitingForOpponent] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);

  const [incomingShot, setIncomingShot] = useState(null);
  const [showIncomingAnimation, setShowIncomingAnimation] = useState(false);
  const [firingAnimation, setFiringAnimation] = useState(null);
  const [showFiringAnimation, setShowFiringAnimation] = useState(false);
  const [turnCount, setTurnCount] = useState(0);

  // Refs
  const peerRef = useRef(null);
  const connRef = useRef(null);
  const gameModeRef = useRef(null);
  const difficultyRef = useRef(difficulty);
  const player1Ref = useRef(player1);
  const player2Ref = useRef(player2);
  const waitingRef = useRef(false);

  useEffect(() => { gameModeRef.current = gameMode; }, [gameMode]);
  useEffect(() => { difficultyRef.current = difficulty; }, [difficulty]);
  useEffect(() => { player1Ref.current = player1; }, [player1]);
  useEffect(() => { player2Ref.current = player2; }, [player2]);
  useEffect(() => { waitingRef.current = waitingForOpponent; }, [waitingForOpponent]);

  const copyToClipboard = async (text) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 2000);
    } catch (err) {
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 2000);
    }
  };

  // Send message
  const sendMsg = useCallback((msg) => {
    if (connRef.current && connRef.current.open) {
      connRef.current.send(msg);
      return true;
    }
    return false;
  }, []);

  // Handle incoming messages
  const onMessage = useCallback((data) => {
    console.log('MSG:', data.type);
    const isHost = gameModeRef.current === 'online-host';

    if (data.type === 'settings') {
      setDifficulty(data.difficulty);
      setGamePhase('setup');
    }
    else if (data.type === 'setup-complete') {
      if (isHost) {
        setPlayer2(p => ({ ...p, grid: data.grid, ships: data.ships, gifts: data.gifts || [] }));
      } else {
        setPlayer1(p => ({ ...p, grid: data.grid, ships: data.ships, gifts: data.gifts || [] }));
      }
      setOpponentSetupReceived(true);
      if (waitingRef.current) {
        setWaitingForOpponent(false);
        setGamePhase('battle');
      }
    }
    else if (data.type === 'shot') {
      handleIncomingShot(data);
    }
    else if (data.type === 'shot-result') {
      handleShotResult(data);
    }
    else if (data.type === 'answer-selected') {
      setSelectedAnswer(data.idx);
    }
    else if (data.type === 'question-answered') {
      setAnswerResult(data.correct);
      setTimeout(() => {
        setWaitingForOpponent(false);
        setIsWatchingQuestion(false);
        setCurrentQuestion(null);
        setSelectedAnswer(null);
        setAnswerResult(null);
        setShotResults([]);
        setExtraTurn(false);
        setSunkShip(null);
        setIsMyTurn(data.correct && data.gotHit ? false : true);
        setGamePhase('battle');
      }, 1500);
    }
    else if (data.type === 'question-retry') {
      setSelectedAnswer(null);
      setAnswerResult(null);
    }
    else if (data.type === 'new-question') {
      setCurrentQuestion(data.question);
      setSelectedAnswer(null);
      setAnswerResult(null);
    }
    else if (data.type === 'game-over') {
      setWinner(data.winner);
      setGamePhase('gameover');
    }
  }, []);

  // Setup connection handlers
  const setupConn = useCallback((conn, isHost) => {
    conn.on('open', () => {
      console.log('Connection OPEN');
      setConnected(true);
      setStatusMsg('Connected!');
      
      if (isHost) {
        // Host sends settings then moves to setup
        setTimeout(() => {
          conn.send({ type: 'settings', difficulty: difficultyRef.current });
          setGamePhase('setup');
        }, 300);
      }
      // Joiner waits for settings message to move to setup
    });

    conn.on('data', onMessage);

    conn.on('close', () => {
      console.log('Connection CLOSED');
      setConnected(false);
      setStatusMsg('Connection lost!');
    });

    conn.on('error', (err) => {
      console.error('Conn error:', err);
      setStatusMsg('Connection error!');
    });
  }, [onMessage]);

  // HOST: Create peer and wait for connection
  const startHost = useCallback(() => {
    if (!window.Peer) {
      setStatusMsg('Error: PeerJS not loaded!');
      return;
    }

    setGameMode('online-host');
    setStatusMsg('Creating game...');
    setIsMyTurn(true);

    const peer = new Peer();
    peerRef.current = peer;

    peer.on('open', (id) => {
      console.log('Host peer open:', id);
      setMyPeerId(id);
      setPeerReady(true);
      setStatusMsg('Share code with opponent');
    });

    peer.on('connection', (conn) => {
      console.log('Incoming connection!');
      connRef.current = conn;
      setStatusMsg('Opponent connecting...');
      setupConn(conn, true);
    });

    peer.on('error', (err) => {
      console.error('Peer error:', err);
      setStatusMsg('Error: ' + err.type);
    });
  }, [setupConn]);

  // JOINER: Create peer
  const startJoin = useCallback(() => {
    if (!window.Peer) {
      setStatusMsg('Error: PeerJS not loaded!');
      return;
    }

    setGameMode('online-joiner');
    setStatusMsg('Initializing...');
    setIsMyTurn(false);

    const peer = new Peer();
    peerRef.current = peer;

    peer.on('open', (id) => {
      console.log('Joiner peer open:', id);
      setMyPeerId(id);
      setPeerReady(true);
      setStatusMsg('Enter host code and connect');
    });

    peer.on('error', (err) => {
      console.error('Peer error:', err);
      setStatusMsg('Error: ' + err.type);
    });
  }, []);

  // JOINER: Connect to host
  const doConnect = useCallback(() => {
    const code = hostCode.trim();
    if (!code) {
      setStatusMsg('Enter the host code first!');
      return;
    }
    if (!peerRef.current) {
      setStatusMsg('Peer not ready - wait a moment');
      return;
    }
    if (!peerReady) {
      setStatusMsg('Still initializing - wait...');
      return;
    }

    setStatusMsg('Connecting to ' + code.substring(0, 8) + '...');

    const conn = peerRef.current.connect(code, { reliable: true });
    connRef.current = conn;
    setupConn(conn, false);
  }, [hostCode, peerReady, setupConn]);

  // Go back to menu
  const goBack = useCallback(() => {
    if (peerRef.current) {
      peerRef.current.destroy();
      peerRef.current = null;
    }
    connRef.current = null;
    setGameMode(null);
    setMyPeerId('');
    setHostCode('');
    setPeerReady(false);
    setConnected(false);
    setStatusMsg('');
  }, []);

  // Handle incoming shot
  const handleIncomingShot = (data) => {
    const { row, col, weapon } = data;
    const isHost = gameModeRef.current === 'online-host';
    const pattern = weapon === 'rain' ? generateRainPattern() : WEAPONS[weapon].pattern;
    const results = [];
    let gotHit = false;

    setWaitingForOpponent(false);

    const myPlayer = isHost ? player1Ref.current : player2Ref.current;
    const setMyPlayer = isHost ? setPlayer1 : setPlayer2;

    const newReceived = myPlayer.received.map(r => [...r]);
    let shipsRemaining = myPlayer.shipsRemaining;
    let sunkShipName = null;
    const myShips = myPlayer.ships.map(s => ({ ...s, cells: [...s.cells] }));
    const myGifts = [...(myPlayer.gifts || [])];
    let collectedGift = null;

    const targetCells = pattern.map(([dx, dy]) => [row + dx, col + dy]);

    targetCells.forEach(([r, c]) => {
      if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && newReceived[r][c] === null) {
        const cell = myPlayer.grid[r][c];
        const giftIdx = myGifts.findIndex(g => g.row === r && g.col === c);
        if (giftIdx !== -1 && !collectedGift) {
          collectedGift = myGifts[giftIdx];
          myGifts.splice(giftIdx, 1);
        }
        if (cell && cell.ship !== undefined) {
          newReceived[r][c] = 'hit';
          gotHit = true;
          results.push({ row: r, col: c, result: 'hit' });
          const ship = myShips[cell.ship];
          if (ship.cells.every(([sr, sc]) => newReceived[sr][sc] === 'hit') && !ship.sunk) {
            ship.sunk = true;
            shipsRemaining--;
            sunkShipName = SHIPS[cell.ship].name;
          }
        } else {
          newReceived[r][c] = 'miss';
          results.push({ row: r, col: c, result: 'miss' });
        }
      }
    });

    setIncomingShot({ results, gotHit, sunkShip: sunkShipName });
    setShowIncomingAnimation(true);
    setMyPlayer(p => ({ ...p, received: newReceived, shipsRemaining, ships: myShips, gifts: myGifts }));

    const question = shipsRemaining > 0 ? getRandomQuestion(difficultyRef.current) : null;
    sendMsg({ type: 'shot-result', results, gotHit, sunkShip: sunkShipName, shipsRemaining, gameOver: shipsRemaining === 0, question, collectedGift });

    setTimeout(() => {
      setShowIncomingAnimation(false);
      setIncomingShot(null);
      if (shipsRemaining === 0) {
        setWinner(isHost ? 2 : 1);
        setGamePhase('gameover');
      } else {
        setCurrentQuestion(question);
        setIsWatchingQuestion(true);
        setGamePhase('question');
      }
    }, 2000);
  };

  const handleShotResult = (data) => {
    const isHost = gameModeRef.current === 'online-host';
    setWaitingForOpponent(false);
    setShotResults(data.results);
    const setMyPlayer = isHost ? setPlayer1 : setPlayer2;

    setMyPlayer(p => {
      const newTracking = p.tracking.map(r => [...r]);
      data.results.forEach(({ row, col, result }) => { newTracking[row][col] = result; });
      const newWeapons = { ...p.weapons };
      if (data.collectedGift) newWeapons[data.collectedGift.weapon] = (newWeapons[data.collectedGift.weapon] || 0) + 1;
      return { ...p, tracking: newTracking, weapons: newWeapons };
    });

    if (data.sunkShip) setSunkShip(data.sunkShip);
    if (data.gameOver) {
      setWinner(isHost ? 1 : 2);
      setGamePhase('gameover');
    } else {
      setExtraTurn(data.gotHit);
      setCurrentQuestion(data.question);
      setIsWatchingQuestion(false);
      setGamePhase('question');
    }
  };

  // Ship placement
  const canPlaceShip = (grid, row, col, size, horiz) => {
    for (let i = 0; i < size; i++) {
      const r = horiz ? row : row + i;
      const c = horiz ? col + i : col;
      if (r >= GRID_SIZE || c >= GRID_SIZE || grid[r][c] !== null) return false;
    }
    return true;
  };

  const placeShip = (row, col) => {
    if (currentShipIndex >= SHIPS.length) return;
    const ship = SHIPS[currentShipIndex];
    const isHost = gameMode === 'online-host';
    const currentGrid = isHost ? player1.grid : player2.grid;
    const grid = currentGrid.map(r => [...r]);

    if (!canPlaceShip(grid, row, col, ship.size, isHorizontal)) return;

    const shipCells = [];
    for (let i = 0; i < ship.size; i++) {
      const r = isHorizontal ? row : row + i;
      const c = isHorizontal ? col + i : col;
      grid[r][c] = { ship: currentShipIndex, part: i };
      shipCells.push([r, c]);
    }

    const newShip = { ...ship, cells: shipCells, sunk: false };
    const newPlacedShips = [...placedShips, newShip];
    setPlacedShips(newPlacedShips);

    if (isHost) setPlayer1(p => ({ ...p, grid, ships: newPlacedShips }));
    else setPlayer2(p => ({ ...p, grid, ships: newPlacedShips }));

    if (currentShipIndex < SHIPS.length - 1) setCurrentShipIndex(currentShipIndex + 1);
    else completeSetup(grid, newPlacedShips);
  };

  const completeSetup = (grid, ships) => {
    const gifts = [];
    const emptyCells = [];
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        if (grid[r][c] === null) emptyCells.push([r, c]);
      }
    }
    for (let i = 0; i < 2 && emptyCells.length > 0; i++) {
      const idx = Math.floor(Math.random() * emptyCells.length);
      const [r, c] = emptyCells.splice(idx, 1)[0];
      const types = ['big', 'rain', 'nuclear'];
      gifts.push({ row: r, col: c, weapon: types[Math.floor(Math.random() * types.length)] });
    }

    const isHost = gameMode === 'online-host';
    if (isHost) setPlayer1(p => ({ ...p, grid, ships, gifts }));
    else setPlayer2(p => ({ ...p, grid, ships, gifts }));

    sendMsg({ type: 'setup-complete', grid, ships, gifts });

    if (opponentSetupReceived) setGamePhase('battle');
    else setWaitingForOpponent(true);
  };

  const randomPlaceShips = () => {
    const grid = createEmptyGrid();
    const ships = [];

    for (let i = 0; i < SHIPS.length; i++) {
      const ship = SHIPS[i];
      let placed = false, attempts = 0;
      while (!placed && attempts < 500) {
        const horiz = Math.random() > 0.5;
        const row = Math.floor(Math.random() * GRID_SIZE);
        const col = Math.floor(Math.random() * GRID_SIZE);
        if (canPlaceShip(grid, row, col, ship.size, horiz)) {
          const cells = [];
          for (let j = 0; j < ship.size; j++) {
            const r = horiz ? row : row + j;
            const c = horiz ? col + j : col;
            grid[r][c] = { ship: i, part: j };
            cells.push([r, c]);
          }
          ships.push({ ...ship, cells, sunk: false });
          placed = true;
        }
        attempts++;
      }
    }

    const isHost = gameMode === 'online-host';
    if (isHost) setPlayer1(p => ({ ...p, grid, ships }));
    else setPlayer2(p => ({ ...p, grid, ships }));
    completeSetup(grid, ships);
  };

  const fireWeapon = (row, col) => {
    if (!isMyTurn || showFiringAnimation) return;
    const isHost = gameMode === 'online-host';
    const attacker = isHost ? player1 : player2;
    if (selectedWeapon !== 'simple' && attacker.weapons[selectedWeapon] <= 0) return;
    const tracking = isHost ? player1.tracking : player2.tracking;
    if (tracking[row][col] !== null) return;

    const pattern = selectedWeapon === 'rain' ? generateRainPattern() : WEAPONS[selectedWeapon].pattern;
    const targets = pattern.map(([dx, dy]) => [row + dx, col + dy]).filter(([r, c]) => r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE);

    setFiringAnimation({ weapon: selectedWeapon, targets, phase: 'launch' });
    setShowFiringAnimation(true);
    setTimeout(() => setFiringAnimation(p => ({ ...p, phase: 'travel' })), 300);
    setTimeout(() => setFiringAnimation(p => ({ ...p, phase: 'impact' })), 800);

    setTimeout(() => {
      setShowFiringAnimation(false);
      setFiringAnimation(null);
      setTurnCount(t => t + 1);
      sendMsg({ type: 'shot', row, col, weapon: selectedWeapon });
      setIsMyTurn(false);
      setWaitingForOpponent(true);

      if (selectedWeapon !== 'simple') {
        const setP = isHost ? setPlayer1 : setPlayer2;
        setP(p => ({ ...p, weapons: { ...p.weapons, [selectedWeapon]: p.weapons[selectedWeapon] - 1 } }));
      }
    }, 1300);
  };

  const handleAnswer = (idx) => {
    if (isWatchingQuestion) return;
    setSelectedAnswer(idx);
    const correct = idx === currentQuestion.answer;
    setAnswerResult(correct);
    sendMsg({ type: 'answer-selected', idx });

    setTimeout(() => {
      if (correct) {
        sendMsg({ type: 'question-answered', correct: true, gotHit: extraTurn });
        setIsMyTurn(extraTurn);
        setCurrentQuestion(null);
        setSelectedAnswer(null);
        setAnswerResult(null);
        setShotResults([]);
        setExtraTurn(false);
        setSunkShip(null);
        setIsWatchingQuestion(false);
        setGamePhase('battle');
      } else {
        sendMsg({ type: 'question-retry' });
        const newQ = getRandomQuestion(difficulty);
        setCurrentQuestion(newQ);
        setSelectedAnswer(null);
        setAnswerResult(null);
        sendMsg({ type: 'new-question', question: newQ });
      }
    }, 1500);
  };

  const renderCell = (row, col, isOwn, playerData, isSetup = false, trackingData = null) => {
    const cell = playerData.grid[row][col];
    const hitData = isOwn ? playerData.received : trackingData;
    const hit = hitData ? hitData[row][col] : null;
    const gift = playerData.gifts?.find(g => g.row === row && g.col === col);
    const hasIncoming = showIncomingAnimation && incomingShot?.results.some(r => r.row === row && r.col === col);
    const incomingRes = hasIncoming ? incomingShot.results.find(r => r.row === row && r.col === col)?.result : null;
    const isFiring = showFiringAnimation && firingAnimation?.targets.some(([r, c]) => r === row && c === col);

    let cls = 'cell';
    let content = '';

    if (isOwn) {
      if (cell?.ship !== undefined) {
        return (
          <div key={`${row}-${col}`} className={`cell ship ${hasIncoming ? 'incoming' : ''}`} style={{ backgroundColor: SHIPS[cell.ship].color }}>
            {(hit === 'hit' || incomingRes === 'hit') && 'üî•'}
            {gift && 'üéÅ'}
          </div>
        );
      }
      if (hit === 'miss' || incomingRes === 'miss') { cls += ' miss'; content = 'üí®'; }
      if (gift && !hit) content = 'üéÅ';
    } else {
      if (hit === 'hit') { cls += ' hit'; content = 'üí•'; }
      else if (hit === 'miss') { cls += ' miss'; content = 'üí®'; }
      else if (gift) { cls += ' enemy gift-cell'; content = 'üéÅ'; }
      else cls += ' enemy';
      if (isFiring) cls += ` firing-${firingAnimation.phase}`;
    }

    const onClick = () => {
      if (isSetup) placeShip(row, col);
      else if (!isOwn && !hit && gamePhase === 'battle' && isMyTurn && !showFiringAnimation) fireWeapon(row, col);
    };

    return <div key={`${row}-${col}`} className={cls} onClick={onClick}>{content}</div>;
  };

  const renderGrid = (isOwn, playerData, isSetup = false, trackingData = null) => (
    <div className="grid-wrapper">
      <div className="grid-labels-top">
        <div className="corner"></div>
        {Array.from({ length: GRID_SIZE }, (_, i) => <div key={i} className="label">{i + 1}</div>)}
      </div>
      <div className="grid-body">
        <div className="grid-labels-side">
          {Array.from({ length: GRID_SIZE }, (_, i) => <div key={i} className="label">{String.fromCharCode(65 + i)}</div>)}
        </div>
        <div className="grid">
          {Array.from({ length: GRID_SIZE }, (_, row) =>
            Array.from({ length: GRID_SIZE }, (_, col) => renderCell(row, col, isOwn, playerData, isSetup, trackingData))
          )}
        </div>
      </div>
    </div>
  );

  const isHost = gameMode === 'online-host';

  const styles = `
    .game-container { min-height:100vh; background:linear-gradient(135deg,#1a1a2e,#16213e,#0f3460); color:#fff; font-family:'Segoe UI',system-ui,sans-serif; padding:20px; display:flex; flex-direction:column; align-items:center; }
    .header { text-align:center; margin-bottom:20px; }
    .title { font-size:2.2rem; font-weight:800; background:linear-gradient(90deg,#00d9ff,#00ff88); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
    .subtitle { color:#8892b0; font-size:0.9rem; }
    .menu-container { display:flex; justify-content:center; align-items:center; flex:1; width:100%; }
    .menu-panel { background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:20px; padding:30px; width:100%; max-width:420px; }
    .menu-title { text-align:center; font-size:1.4rem; margin-bottom:25px; color:#00d9ff; }
    .menu-btn { width:100%; padding:14px; margin:8px 0; border:none; border-radius:10px; font-size:1rem; cursor:pointer; background:linear-gradient(135deg,#334155,#1e293b); color:#fff; transition:transform 0.2s; }
    .menu-btn:hover { transform:translateY(-2px); }
    .menu-btn.primary { background:linear-gradient(135deg,#00d9ff,#00ff88); color:#1a1a2e; font-weight:bold; }
    .menu-btn.back { background:transparent; border:2px solid #334155; margin-top:15px; }
    .menu-btn:disabled { opacity:0.5; cursor:not-allowed; transform:none; }
    .conn-panel { margin-top:20px; padding:20px; background:rgba(0,0,0,0.3); border-radius:12px; }
    .conn-title { font-size:1.1rem; color:#00d9ff; margin-bottom:12px; text-align:center; }
    .diff-selector { margin-bottom:18px; }
    .diff-label { display:block; text-align:center; margin-bottom:8px; color:#8892b0; font-size:0.9rem; }
    .diff-btns { display:flex; gap:8px; justify-content:center; }
    .diff-btn { padding:8px 16px; border:2px solid #334155; background:transparent; color:#fff; border-radius:8px; cursor:pointer; }
    .diff-btn:hover,.diff-btn.active { border-color:#00d9ff; background:rgba(0,217,255,0.15); }
    .code-display { background:rgba(0,0,0,0.5); padding:14px; border-radius:8px; font-family:monospace; font-size:0.8rem; word-break:break-all; margin:10px 0; text-align:center; cursor:pointer; border:2px solid transparent; }
    .code-display:hover { border-color:#00d9ff; }
    .code-display.copied { border-color:#00ff88; background:rgba(0,255,136,0.1); }
    .copy-hint { font-size:0.7rem; color:#8892b0; text-align:center; }
    .copy-hint.success { color:#00ff88; }
    .code-input { width:100%; padding:12px; border:2px solid #334155; border-radius:8px; background:rgba(0,0,0,0.4); color:#fff; font-size:0.95rem; margin:8px 0; }
    .code-input:focus { outline:none; border-color:#00d9ff; }
    .status-box { display:flex; align-items:center; justify-content:center; gap:10px; margin-top:12px; padding:10px; background:rgba(0,0,0,0.2); border-radius:8px; font-size:0.9rem; }
    .status-dot { width:10px; height:10px; border-radius:50%; background:#ef4444; }
    .status-dot.ready { background:#fbbf24; }
    .status-dot.connected { background:#22c55e; box-shadow:0 0 8px #22c55e; }
    .setup-container { display:flex; flex-direction:column; align-items:center; max-width:600px; }
    .setup-header { text-align:center; margin-bottom:15px; }
    .player-ind { font-size:1.3rem; font-weight:bold; color:#00d9ff; margin-bottom:12px; }
    .ship-info { display:flex; align-items:center; gap:12px; margin-bottom:12px; }
    .ship-preview { display:flex; gap:2px; }
    .ship-cell { width:22px; height:22px; border-radius:3px; }
    .setup-controls { display:flex; gap:8px; }
    .ctrl-btn { padding:8px 14px; border:2px solid #334155; background:transparent; color:#fff; border-radius:8px; cursor:pointer; }
    .ctrl-btn:hover,.ctrl-btn.active { border-color:#00d9ff; background:rgba(0,217,255,0.1); }
    .grid-wrapper { display:inline-block; }
    .grid-labels-top { display:flex; }
    .corner { width:28px; height:28px; }
    .label { width:32px; height:28px; display:flex; align-items:center; justify-content:center; font-weight:bold; color:#8892b0; font-size:0.75rem; }
    .grid-body { display:flex; }
    .grid-labels-side { display:flex; flex-direction:column; }
    .grid-labels-side .label { width:28px; height:32px; }
    .grid { display:grid; grid-template-columns:repeat(10,32px); gap:2px; background:rgba(0,0,0,0.3); padding:4px; border-radius:8px; }
    .cell { width:32px; height:32px; background:rgba(0,100,150,0.3); border-radius:3px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:1rem; }
    .cell:hover { background:rgba(0,200,255,0.3); }
    .cell.ship { cursor:default; }
    .cell.enemy:hover { background:rgba(255,100,100,0.4); }
    .cell.hit { background:rgba(255,100,100,0.6); }
    .cell.miss { background:rgba(100,100,100,0.4); }
    .cell.gift-cell { background:rgba(255,200,0,0.3); border:2px solid #fbbf24; }
    .cell.incoming { animation:pulse 0.5s infinite; }
    .cell.firing-launch { background:rgba(255,200,0,0.4); }
    .cell.firing-travel { background:rgba(255,150,0,0.5); }
    .cell.firing-impact { background:rgba(255,100,0,0.7); }
    @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.1)} }
    .battle-container { display:flex; flex-direction:column; align-items:center; width:100%; max-width:1000px; }
    .battle-header { text-align:center; margin-bottom:12px; }
    .turn-ind { font-size:1.2rem; font-weight:bold; padding:10px 18px; border-radius:10px; display:inline-block; }
    .turn-ind.my { color:#00ff88; background:rgba(0,255,136,0.15); border:2px solid #00ff88; }
    .turn-ind.wait { color:#fbbf24; background:rgba(251,191,36,0.15); border:2px solid #fbbf24; }
    .grids { display:flex; justify-content:center; gap:25px; flex-wrap:wrap; }
    .grid-section { text-align:center; }
    .grid-title { font-size:1rem; margin-bottom:6px; color:#00d9ff; font-weight:bold; }
    .ships-status { display:flex; flex-wrap:wrap; gap:4px; justify-content:center; margin-top:8px; }
    .ship-stat { padding:3px 6px; background:rgba(0,150,100,0.3); border-radius:4px; font-size:0.65rem; }
    .ship-stat.sunk { background:rgba(200,50,50,0.5); text-decoration:line-through; }
    .weapons-panel { margin-top:15px; text-align:center; }
    .weapons-title { font-size:1rem; margin-bottom:8px; color:#00d9ff; }
    .weapons-grid { display:flex; justify-content:center; gap:6px; flex-wrap:wrap; }
    .weapon-btn { display:flex; flex-direction:column; align-items:center; padding:6px 10px; border:2px solid #334155; background:rgba(0,0,0,0.3); color:#fff; border-radius:8px; cursor:pointer; min-width:65px; }
    .weapon-btn:hover:not(:disabled) { border-color:#00d9ff; }
    .weapon-btn.selected { border-color:#00ff88; background:rgba(0,255,136,0.2); }
    .weapon-btn:disabled { opacity:0.4; cursor:not-allowed; }
    .weapon-icon { font-size:1.2rem; }
    .weapon-name { font-size:0.65rem; }
    .weapon-count { font-size:0.7rem; color:#00d9ff; font-weight:bold; }
    .question-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center; z-index:100; }
    .question-modal { background:linear-gradient(135deg,#1a1a2e,#16213e); border:2px solid #00d9ff; border-radius:16px; padding:25px; max-width:450px; width:90%; text-align:center; }
    .shot-result { margin-bottom:15px; padding:12px; border-radius:8px; background:rgba(100,100,100,0.3); }
    .shot-result.hit { background:rgba(255,100,100,0.3); border:1px solid #e74c3c; }
    .shot-result-text { font-size:1.3rem; font-weight:bold; }
    .sunk-ann { color:#f39c12; font-weight:bold; margin-top:8px; }
    .extra-notice { color:#00ff88; font-weight:bold; margin-top:8px; }
    .watching-ind { background:rgba(0,217,255,0.2); border:2px solid #00d9ff; border-radius:8px; padding:12px; margin-bottom:15px; color:#00d9ff; }
    .q-header { font-size:1.1rem; color:#00d9ff; margin-bottom:12px; }
    .q-text { font-size:1.2rem; margin-bottom:15px; }
    .options { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .opt-btn { padding:12px; border:2px solid #334155; background:rgba(0,0,0,0.3); color:#fff; border-radius:8px; font-size:0.95rem; cursor:pointer; }
    .opt-btn:hover:not(:disabled) { border-color:#00d9ff; }
    .opt-btn.selected { border-color:#f39c12; background:rgba(243,156,18,0.2); }
    .opt-btn.correct { border-color:#22c55e; background:rgba(34,197,94,0.3); }
    .opt-btn.incorrect { border-color:#ef4444; background:rgba(239,68,68,0.3); }
    .feedback { margin-top:12px; font-size:1.1rem; font-weight:bold; }
    .feedback.correct { color:#22c55e; }
    .feedback.incorrect { color:#ef4444; }
    .gameover-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:100; }
    .gameover-content { text-align:center; }
    .gameover-title { font-size:2.5rem; margin-bottom:15px; }
    .winner-text { font-size:1.8rem; color:#00d9ff; margin-bottom:25px; }
    .gameover-btn { padding:12px 35px; font-size:1.1rem; border:none; border-radius:10px; background:linear-gradient(135deg,#00d9ff,#00ff88); color:#1a1a2e; font-weight:bold; cursor:pointer; }
    .waiting-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; z-index:50; }
    .waiting-content { text-align:center; }
    .spinner { width:40px; height:40px; border:4px solid rgba(255,255,255,0.2); border-top-color:#00d9ff; border-radius:50%; animation:spin 1s linear infinite; margin:0 auto 15px; }
    @keyframes spin { to{transform:rotate(360deg)} }
    .incoming-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.8); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:50; }
    .incoming-title { font-size:1.8rem; color:#ef4444; margin-bottom:20px; animation:blink 0.5s infinite alternate; }
    @keyframes blink { from{opacity:0.7} to{opacity:1} }
    .incoming-result { font-size:1.3rem; margin-top:15px; }
    .incoming-result.hit { color:#ef4444; }
    .incoming-result.miss { color:#8892b0; }
    @media(max-width:768px) { .title{font-size:1.5rem} .grids{flex-direction:column;align-items:center} .grid{grid-template-columns:repeat(10,28px)} .cell{width:28px;height:28px;font-size:0.85rem} .label{width:28px;height:24px;font-size:0.65rem} .grid-labels-side .label{width:24px;height:28px} .corner{width:24px;height:24px} }
  `;

  return (
    <div className="game-container">
      <style>{styles}</style>
      <div className="header">
        <h1 className="title">‚öì Battleship ESL ‚öì</h1>
        <p className="subtitle">Naval Combat Grammar Challenge</p>
      </div>

      {/* MENU */}
      {gamePhase === 'menu' && (
        <div className="menu-container">
          <div className="menu-panel">
            <div className="menu-title">üéÆ Online Multiplayer</div>

            {!gameMode && (
              <>
                <button className="menu-btn primary" onClick={startHost}>üåê Host Game</button>
                <button className="menu-btn" onClick={startJoin}>üîó Join Game</button>
              </>
            )}

            {gameMode === 'online-host' && (
              <div className="conn-panel">
                <div className="conn-title">üåê Hosting Game</div>

                <div className="diff-selector">
                  <span className="diff-label">Difficulty</span>
                  <div className="diff-btns">
                    <button className={`diff-btn ${difficulty==='easy'?'active':''}`} onClick={()=>setDifficulty('easy')}>Easy</button>
                    <button className={`diff-btn ${difficulty==='medium'?'active':''}`} onClick={()=>setDifficulty('medium')}>Medium</button>
                    <button className={`diff-btn ${difficulty==='hard'?'active':''}`} onClick={()=>setDifficulty('hard')}>Hard</button>
                  </div>
                </div>

                <div style={{textAlign:'center',marginBottom:'8px'}}>Your game code:</div>
                <div className={`code-display ${copySuccess?'copied':''}`} onClick={()=>myPeerId&&copyToClipboard(myPeerId)}>
                  {myPeerId || 'Generating...'}
                </div>
                <div className={`copy-hint ${copySuccess?'success':''}`}>{copySuccess ? '‚úì Copied!' : 'Tap to copy'}</div>

                <div className="status-box">
                  <div className={`status-dot ${connected?'connected':peerReady?'ready':''}`}></div>
                  <span>{statusMsg}</span>
                </div>

                <button className="menu-btn back" onClick={goBack}>‚Üê Back</button>
              </div>
            )}

            {gameMode === 'online-joiner' && (
              <div className="conn-panel">
                <div className="conn-title">üîó Join Game</div>

                <div style={{textAlign:'center',marginBottom:'8px'}}>Enter host's code:</div>
                <input
                  className="code-input"
                  type="text"
                  placeholder="Paste code here"
                  value={hostCode}
                  onChange={(e) => setHostCode(e.target.value)}
                />

                <button
                  className="menu-btn primary"
                  onClick={doConnect}
                  disabled={!peerReady || !hostCode.trim()}
                >
                  {peerReady ? 'Connect' : 'Initializing...'}
                </button>

                <div className="status-box">
                  <div className={`status-dot ${connected?'connected':peerReady?'ready':''}`}></div>
                  <span>{statusMsg}</span>
                </div>

                <button className="menu-btn back" onClick={goBack}>‚Üê Back</button>
              </div>
            )}
          </div>
        </div>
      )}

      {/* SETUP */}
      {gamePhase === 'setup' && (
        <div className="setup-container">
          <div className="setup-header">
            <div className="player-ind">Place Your Ships</div>
            {currentShipIndex < SHIPS.length && (
              <div className="ship-info">
                <div className="ship-preview">
                  {Array.from({length:SHIPS[currentShipIndex].size},(_,i)=>(
                    <div key={i} className="ship-cell" style={{backgroundColor:SHIPS[currentShipIndex].color}}/>
                  ))}
                </div>
                <div>
                  <div style={{fontWeight:'bold'}}>{SHIPS[currentShipIndex].name}</div>
                  <div style={{fontSize:'0.8rem',color:'#8892b0'}}>Size: {SHIPS[currentShipIndex].size}</div>
                </div>
              </div>
            )}
            <div className="setup-controls">
              <button className={`ctrl-btn ${isHorizontal?'active':''}`} onClick={()=>setIsHorizontal(true)}>Horizontal</button>
              <button className={`ctrl-btn ${!isHorizontal?'active':''}`} onClick={()=>setIsHorizontal(false)}>Vertical</button>
              <button className="ctrl-btn" onClick={randomPlaceShips}>Random</button>
            </div>
          </div>
          {renderGrid(true, isHost ? player1 : player2, true)}
        </div>
      )}

      {waitingForOpponent && gamePhase === 'setup' && (
        <div className="waiting-overlay">
          <div className="waiting-content">
            <div className="spinner"></div>
            <div>Waiting for opponent...</div>
          </div>
        </div>
      )}

      {/* BATTLE */}
      {gamePhase === 'battle' && (
        <div className="battle-container">
          <div className="battle-header">
            <div className={`turn-ind ${isMyTurn?'my':'wait'}`}>
              {isMyTurn ? 'üéØ Your Turn!' : '‚è≥ Opponent\'s Turn'}
            </div>
          </div>
          <div className="grids">
            <div className="grid-section">
              <div className="grid-title">üéØ Enemy Waters</div>
              {renderGrid(false, isHost?player2:player1, false, isHost?player1.tracking:player2.tracking)}
            </div>
            <div className="grid-section">
              <div className="grid-title">‚öì Your Fleet</div>
              {renderGrid(true, isHost?player1:player2)}
              <div className="ships-status">
                {SHIPS.map((s,i)=>{
                  const ships = isHost?player1.ships:player2.ships;
                  return <div key={i} className={`ship-stat ${ships[i]?.sunk?'sunk':''}`}>{s.name}</div>;
                })}
              </div>
            </div>
          </div>
          <div className="weapons-panel">
            <div className="weapons-title">‚öîÔ∏è Weapons</div>
            <div className="weapons-grid">
              {Object.entries(WEAPONS).map(([k,w])=>{
                const weaps = isHost?player1.weapons:player2.weapons;
                return (
                  <button key={k} className={`weapon-btn ${selectedWeapon===k?'selected':''}`} onClick={()=>setSelectedWeapon(k)} disabled={(k!=='simple'&&weaps[k]<=0)||!isMyTurn||showFiringAnimation}>
                    <span className="weapon-icon">{w.icon}</span>
                    <span className="weapon-name">{w.name}</span>
                    <span className="weapon-count">{k==='simple'?'‚àû':weaps[k]}</span>
                  </button>
                );
              })}
            </div>
          </div>
        </div>
      )}

      {/* QUESTION */}
      {gamePhase === 'question' && currentQuestion && (
        <div className="question-overlay">
          <div className="question-modal">
            {isWatchingQuestion ? (
              <>
                <div className={`shot-result ${incomingShot?.gotHit?'hit':''}`}>
                  <div className="shot-result-text">{incomingShot?.gotHit?'üí• HIT!':'üí® MISS!'}</div>
                  {incomingShot?.sunkShip && <div className="sunk-ann">üö¢ {incomingShot.sunkShip} sunk!</div>}
                </div>
                <div className="watching-ind">üëÄ Opponent answering...</div>
              </>
            ) : (
              <div className={`shot-result ${shotResults.some(r=>r.result==='hit')?'hit':''}`}>
                <div className="shot-result-text">{shotResults.some(r=>r.result==='hit')?'üí• HIT!':'üí® MISS!'}</div>
                {sunkShip && <div className="sunk-ann">üö¢ You sunk {sunkShip}!</div>}
                {extraTurn && <div className="extra-notice">‚ö° Correct = another turn!</div>}
              </div>
            )}
            <div className="q-header">üìö Grammar ({difficulty})</div>
            <div className="q-text">{currentQuestion.q}</div>
            <div className="options">
              {currentQuestion.options.map((opt,i)=>(
                <button key={i} className={`opt-btn ${selectedAnswer===i?'selected':''} ${answerResult!==null&&i===currentQuestion.answer?'correct':''} ${answerResult===false&&selectedAnswer===i?'incorrect':''}`} onClick={()=>handleAnswer(i)} disabled={selectedAnswer!==null||isWatchingQuestion}>
                  {opt}
                </button>
              ))}
            </div>
            {answerResult!==null && <div className={`feedback ${answerResult?'correct':'incorrect'}`}>{answerResult?'‚úì Correct!':'‚úó Try again!'}</div>}
          </div>
        </div>
      )}

      {/* GAME OVER */}
      {gamePhase === 'gameover' && (
        <div className="gameover-overlay">
          <div className="gameover-content">
            <div className="gameover-title">üèÜ Game Over! üèÜ</div>
            <div className="winner-text">{winner===(isHost?1:2)?'You Win!':'You Lose!'}</div>
            <button className="gameover-btn" onClick={()=>window.location.reload()}>Play Again</button>
          </div>
        </div>
      )}

      {/* INCOMING ATTACK */}
      {showIncomingAnimation && incomingShot && (
        <div className="incoming-overlay">
          <div className="incoming-title">‚ö†Ô∏è INCOMING! ‚ö†Ô∏è</div>
          {renderGrid(true, isHost?player1:player2)}
          <div className={`incoming-result ${incomingShot.gotHit?'hit':'miss'}`}>
            {incomingShot.gotHit?'üí• Hit!':'üí® Miss!'}
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.render(<BattleshipESL />, document.getElementById('root'));
  </script>
</body>
</html>
