<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battleship ESL - Naval Combat Grammar Challenge</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { height: 100%; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
// ============================================
// BATTLESHIP ESL - VERSION 9.6 (NO OVERLAY + DYNAMIC AIRDROPS + MORE QUESTIONS)
// ============================================

const grammarQuestions = {
  easy: [
    // Be verbs
    { q: "I ___ a student.", options: ["am", "is", "are", "be"], answer: 0 },
    { q: "She ___ my sister.", options: ["am", "is", "are", "be"], answer: 1 },
    { q: "They ___ playing football.", options: ["is", "am", "are", "be"], answer: 2 },
    { q: "We ___ happy today.", options: ["is", "am", "are", "be"], answer: 2 },
    { q: "The cat ___ on the table.", options: ["is", "are", "am", "be"], answer: 0 },
    { q: "My parents ___ at home.", options: ["is", "am", "are", "be"], answer: 2 },
    { q: "The sun ___ bright.", options: ["is", "are", "am", "be"], answer: 0 },
    { q: "You ___ very tall.", options: ["is", "am", "are", "be"], answer: 2 },
    // Articles
    { q: "This is ___ apple.", options: ["a", "an", "the", "some"], answer: 1 },
    { q: "I see ___ elephant.", options: ["a", "an", "the", "some"], answer: 1 },
    { q: "She has ___ umbrella.", options: ["a", "an", "the", "some"], answer: 1 },
    { q: "He is ___ honest man.", options: ["a", "an", "the", "some"], answer: 1 },
    { q: "I want ___ banana.", options: ["a", "an", "the", "some"], answer: 0 },
    { q: "Give me ___ book on the table.", options: ["a", "an", "the", "some"], answer: 2 },
    // Have/Has
    { q: "He ___ a dog.", options: ["have", "has", "having", "had"], answer: 1 },
    { q: "They ___ many toys.", options: ["have", "has", "having", "had"], answer: 0 },
    { q: "She ___ blue eyes.", options: ["have", "has", "having", "had"], answer: 1 },
    { q: "We ___ a big house.", options: ["have", "has", "having", "had"], answer: 0 },
    { q: "The dog ___ a long tail.", options: ["have", "has", "having", "had"], answer: 1 },
    // Simple present
    { q: "She ___ to school every day.", options: ["go", "goes", "going", "went"], answer: 1 },
    { q: "He ___ breakfast at 7am.", options: ["eat", "eats", "eating", "ate"], answer: 1 },
    { q: "They ___ English very well.", options: ["speak", "speaks", "speaking", "spoke"], answer: 0 },
    { q: "My mother ___ delicious food.", options: ["cook", "cooks", "cooking", "cooked"], answer: 1 },
    { q: "The bird ___ in the sky.", options: ["fly", "flies", "flying", "flew"], answer: 1 },
    { q: "Water ___ at 100 degrees.", options: ["boil", "boils", "boiling", "boiled"], answer: 1 },
    // Present continuous
    { q: "I like ___ ice cream.", options: ["eat", "eating", "ate", "eats"], answer: 1 },
    { q: "She is ___ a book now.", options: ["read", "reads", "reading", "red"], answer: 2 },
    { q: "They are ___ in the park.", options: ["play", "plays", "playing", "played"], answer: 2 },
    { q: "He is ___ his homework.", options: ["do", "does", "doing", "did"], answer: 2 },
    { q: "We are ___ to music.", options: ["listen", "listens", "listening", "listened"], answer: 2 },
    // Question words
    { q: "___ is your name?", options: ["Who", "What", "Where", "When"], answer: 1 },
    { q: "___ do you live?", options: ["Who", "What", "Where", "When"], answer: 2 },
    { q: "___ is your birthday?", options: ["Who", "What", "Where", "When"], answer: 3 },
    { q: "___ is your teacher?", options: ["Who", "What", "Where", "When"], answer: 0 },
    { q: "___ are you crying?", options: ["Who", "What", "Where", "Why"], answer: 3 },
    { q: "___ books do you have?", options: ["How many", "How much", "What", "Where"], answer: 0 },
    // Negatives
    { q: "She ___ not like vegetables.", options: ["do", "does", "is", "are"], answer: 1 },
    { q: "I ___ not understand.", options: ["do", "does", "is", "are"], answer: 0 },
    { q: "They ___ not coming today.", options: ["do", "does", "is", "are"], answer: 3 },
    { q: "He ___ not play tennis.", options: ["do", "does", "is", "are"], answer: 1 },
    // There is/are
    { q: "There ___ two birds.", options: ["is", "are", "am", "be"], answer: 1 },
    { q: "There ___ a cat in the garden.", options: ["is", "are", "am", "be"], answer: 0 },
    { q: "There ___ many people here.", options: ["is", "are", "am", "be"], answer: 1 },
    { q: "There ___ some water in the glass.", options: ["is", "are", "am", "be"], answer: 0 },
    // Can
    { q: "I can ___ a bike.", options: ["ride", "rides", "riding", "rode"], answer: 0 },
    { q: "She can ___ very fast.", options: ["run", "runs", "running", "ran"], answer: 0 },
    { q: "Can you ___ me?", options: ["help", "helps", "helping", "helped"], answer: 0 },
    { q: "Birds can ___ in the sky.", options: ["fly", "flies", "flying", "flew"], answer: 0 },
    // Prepositions
    { q: "The cat is ___ the table.", options: ["in", "on", "at", "to"], answer: 1 },
    { q: "We go to school ___ Monday.", options: ["in", "on", "at", "to"], answer: 1 },
    { q: "I wake up ___ 7 o'clock.", options: ["in", "on", "at", "to"], answer: 2 },
    { q: "She lives ___ London.", options: ["in", "on", "at", "to"], answer: 0 },
    { q: "The book is ___ the bag.", options: ["in", "on", "at", "to"], answer: 0 },
    { q: "He is waiting ___ the bus stop.", options: ["in", "on", "at", "to"], answer: 2 },
    // Possessives
    { q: "This is ___ book.", options: ["I", "me", "my", "mine"], answer: 2 },
    { q: "That car is ___.", options: ["they", "them", "their", "theirs"], answer: 3 },
    { q: "___ name is John.", options: ["He", "Him", "His", "He's"], answer: 2 },
    { q: "The dog wagged ___ tail.", options: ["it", "it's", "its", "its'"], answer: 2 }
  ],
  medium: [
    // Present perfect
    { q: "She ___ finished her homework.", options: ["have", "has", "had", "having"], answer: 1 },
    { q: "I ___ never been to Japan.", options: ["have", "has", "had", "having"], answer: 0 },
    { q: "They ___ already eaten lunch.", options: ["have", "has", "had", "having"], answer: 0 },
    { q: "He ___ lived here for 10 years.", options: ["have", "has", "had", "having"], answer: 1 },
    { q: "We ___ just arrived.", options: ["have", "has", "had", "having"], answer: 0 },
    { q: "___ you ever seen a whale?", options: ["Have", "Has", "Had", "Do"], answer: 0 },
    { q: "She ___ known him since childhood.", options: ["have", "has", "had", "having"], answer: 1 },
    // Past tense
    { q: "She ___ studying when I called.", options: ["is", "was", "were", "been"], answer: 1 },
    { q: "They ___ at the party yesterday.", options: ["is", "was", "were", "been"], answer: 2 },
    { q: "I ___ to the store last night.", options: ["go", "goes", "went", "gone"], answer: 2 },
    { q: "He ___ his keys yesterday.", options: ["lose", "loses", "lost", "losing"], answer: 2 },
    { q: "We ___ a great movie last week.", options: ["see", "sees", "saw", "seen"], answer: 2 },
    { q: "She ___ me a letter.", options: ["write", "writes", "wrote", "written"], answer: 2 },
    // Conditionals
    { q: "If it rains, I ___ stay home.", options: ["will", "would", "can", "could"], answer: 0 },
    { q: "If I ___ rich, I would travel.", options: ["am", "was", "were", "be"], answer: 2 },
    { q: "I ___ help you if I had time.", options: ["will", "would", "can", "shall"], answer: 1 },
    { q: "If she studies, she ___ pass.", options: ["will", "would", "can", "could"], answer: 0 },
    { q: "What ___ you do if you won?", options: ["will", "would", "can", "shall"], answer: 1 },
    // Comparatives
    { q: "The movie was ___ than I expected.", options: ["good", "better", "best", "more good"], answer: 1 },
    { q: "She is ___ than her sister.", options: ["tall", "taller", "tallest", "more tall"], answer: 1 },
    { q: "This book is ___ than that one.", options: ["interesting", "more interesting", "most interesting", "interestinger"], answer: 1 },
    { q: "He runs ___ than me.", options: ["fast", "faster", "fastest", "more fast"], answer: 1 },
    { q: "This is the ___ day of my life!", options: ["happy", "happier", "happiest", "more happy"], answer: 2 },
    { q: "She is the ___ student in class.", options: ["smart", "smarter", "smartest", "more smart"], answer: 2 },
    // Relative clauses
    { q: "He asked me ___ I was going.", options: ["where", "what", "which", "who"], answer: 0 },
    { q: "The man ___ called is my uncle.", options: ["who", "which", "what", "where"], answer: 0 },
    { q: "The book ___ I read was great.", options: ["who", "which", "what", "where"], answer: 1 },
    { q: "This is the place ___ we met.", options: ["who", "which", "what", "where"], answer: 3 },
    { q: "The woman ___ bag was stolen called police.", options: ["who", "whose", "which", "whom"], answer: 1 },
    // Wish
    { q: "I wish I ___ fly.", options: ["can", "could", "will", "would"], answer: 1 },
    { q: "She wishes she ___ taller.", options: ["is", "was", "were", "be"], answer: 2 },
    { q: "I wish I ___ studied harder.", options: ["have", "has", "had", "having"], answer: 2 },
    { q: "He wishes he ___ speak French.", options: ["can", "could", "will", "would"], answer: 1 },
    // Conjunctions
    { q: "Neither Tom ___ Jerry came.", options: ["or", "nor", "and", "but"], answer: 1 },
    { q: "I like tea ___ coffee.", options: ["or", "nor", "and", "but"], answer: 2 },
    { q: "She is smart ___ lazy.", options: ["or", "nor", "and", "but"], answer: 3 },
    { q: "Either you ___ I will go.", options: ["or", "nor", "and", "but"], answer: 0 },
    { q: "I was tired, ___ I kept working.", options: ["so", "but", "and", "or"], answer: 1 },
    // Time expressions
    { q: "I have been waiting ___ two hours.", options: ["since", "for", "from", "during"], answer: 1 },
    { q: "She has lived here ___ 2010.", options: ["since", "for", "from", "during"], answer: 0 },
    { q: "I worked ___ the summer.", options: ["since", "for", "from", "during"], answer: 3 },
    { q: "We've been friends ___ many years.", options: ["since", "for", "from", "during"], answer: 1 },
    // Passive voice
    { q: "The book ___ by Shakespeare.", options: ["wrote", "written", "was written", "is writing"], answer: 2 },
    { q: "The cake ___ by my mother.", options: ["made", "was made", "is making", "makes"], answer: 1 },
    { q: "English ___ in many countries.", options: ["speak", "speaks", "is spoken", "speaking"], answer: 2 },
    { q: "The letter ___ yesterday.", options: ["sent", "was sent", "is sent", "sending"], answer: 1 },
    { q: "The window ___ by the storm.", options: ["broke", "was broken", "is broken", "breaking"], answer: 1 },
    // Modal verbs
    { q: "You ___ see a doctor.", options: ["should", "can", "may", "might"], answer: 0 },
    { q: "She ___ be at home now.", options: ["must", "should", "can", "will"], answer: 0 },
    { q: "___ I use your phone?", options: ["Must", "Should", "May", "Will"], answer: 2 },
    { q: "You ___ smoke here.", options: ["mustn't", "shouldn't", "can't", "won't"], answer: 0 },
    { q: "He ___ to work harder.", options: ["should", "ought", "must", "can"], answer: 1 },
    // Gerunds/Infinitives
    { q: "I enjoy ___ books.", options: ["read", "to read", "reading", "reads"], answer: 2 },
    { q: "She wants ___ a doctor.", options: ["become", "to become", "becoming", "becomes"], answer: 1 },
    { q: "He avoided ___ me.", options: ["meet", "to meet", "meeting", "meets"], answer: 2 },
    { q: "I hope ___ you soon.", options: ["see", "to see", "seeing", "sees"], answer: 1 },
    { q: "They finished ___ the project.", options: ["complete", "to complete", "completing", "completes"], answer: 2 }
  ],
  hard: [
    // Third conditional
    { q: "Had I known, I ___ differently.", options: ["would act", "would have acted", "will act", "acted"], answer: 1 },
    { q: "If she had studied, she ___.", options: ["would pass", "would have passed", "will pass", "passed"], answer: 1 },
    { q: "I ___ if I had seen him.", options: ["would tell", "would have told", "will tell", "told"], answer: 1 },
    { q: "Had they arrived earlier, they ___ the show.", options: ["would catch", "would have caught", "will catch", "caught"], answer: 1 },
    // Inversion
    { q: "Not only ___ late, but he also forgot.", options: ["he was", "was he", "he is", "is he"], answer: 1 },
    { q: "Never ___ such beauty.", options: ["I have seen", "have I seen", "I saw", "did I see"], answer: 1 },
    { q: "Rarely ___ so much talent.", options: ["we see", "do we see", "we saw", "did we saw"], answer: 1 },
    { q: "Seldom ___ on time.", options: ["he arrives", "does he arrive", "he arrived", "did he arrived"], answer: 1 },
    { q: "Little ___ that he would win.", options: ["he knew", "did he know", "he did know", "knew he"], answer: 1 },
    { q: "Only then ___ the truth.", options: ["I realized", "did I realize", "I did realize", "realized I"], answer: 1 },
    // Future perfect
    { q: "The report ___ by tomorrow.", options: ["will finish", "will be finished", "finishes", "is finishing"], answer: 1 },
    { q: "By next year, I ___ graduated.", options: ["will", "will have", "would", "would have"], answer: 1 },
    { q: "She ___ the book by tonight.", options: ["will read", "will have read", "reads", "is reading"], answer: 1 },
    { q: "They ___ for 20 years next month.", options: ["will marry", "will have been married", "are married", "were married"], answer: 1 },
    // Subjunctive
    { q: "It's essential that he ___ on time.", options: ["is", "be", "was", "were"], answer: 1 },
    { q: "I suggest that she ___ early.", options: ["leaves", "leave", "left", "leaving"], answer: 1 },
    { q: "It's important that everyone ___ present.", options: ["is", "be", "are", "were"], answer: 1 },
    { q: "The doctor recommended that he ___ rest.", options: ["gets", "get", "got", "getting"], answer: 1 },
    // Complex time clauses
    { q: "Scarcely had I arrived ___ it started raining.", options: ["than", "when", "then", "that"], answer: 1 },
    { q: "No sooner had she left ___ the phone rang.", options: ["when", "than", "then", "that"], answer: 1 },
    { q: "Hardly had we begun ___ it ended.", options: ["when", "than", "then", "before"], answer: 0 },
    { q: "Barely had he spoken ___ she interrupted.", options: ["when", "than", "then", "that"], answer: 0 },
    // High time / It's time
    { q: "It's high time you ___ a decision.", options: ["make", "made", "making", "to make"], answer: 1 },
    { q: "It's time we ___ home.", options: ["go", "went", "going", "to go"], answer: 1 },
    { q: "It's about time she ___ the truth.", options: ["knows", "knew", "know", "knowing"], answer: 1 },
    { q: "It's high time they ___ their act together.", options: ["get", "got", "getting", "to get"], answer: 1 },
    // Mixed conditionals
    { q: "Were it not for his help, I ___.", options: ["would fail", "would have failed", "will fail", "failed"], answer: 1 },
    { q: "Had I been there, I ___ now.", options: ["would know", "would have known", "will know", "knew"], answer: 0 },
    { q: "If she had taken the job, she ___ in Paris now.", options: ["would live", "would have lived", "will live", "lived"], answer: 0 },
    // Correlative comparatives
    { q: "The more you practice, ___.", options: ["better you get", "the better you get", "you get better", "best you get"], answer: 1 },
    { q: "___ I learn, the less I know.", options: ["More", "The more", "Most", "The most"], answer: 1 },
    { q: "The sooner we leave, ___.", options: ["better", "the better", "best", "the best"], answer: 1 },
    { q: "The harder he works, ___ he earns.", options: ["more", "the more", "most", "the most"], answer: 1 },
    // Past subjunctive
    { q: "I wish he ___ here yesterday.", options: ["was", "were", "had been", "has been"], answer: 2 },
    { q: "If only I ___ the answer then.", options: ["know", "knew", "had known", "have known"], answer: 2 },
    { q: "She acts as if she ___ the boss.", options: ["is", "was", "were", "be"], answer: 2 },
    { q: "He talks as though he ___ everything.", options: ["knows", "knew", "know", "known"], answer: 1 },
    // Cleft sentences
    { q: "It ___ John who broke the window.", options: ["is", "was", "were", "be"], answer: 1 },
    { q: "What I need ___ a vacation.", options: ["is", "are", "was", "were"], answer: 0 },
    { q: "It was in Paris ___ they met.", options: ["where", "that", "which", "when"], answer: 1 },
    { q: "All I want ___ peace.", options: ["is", "are", "was", "were"], answer: 0 },
    // Advanced passive
    { q: "He is said ___ very rich.", options: ["be", "to be", "being", "been"], answer: 1 },
    { q: "She is believed ___ left the country.", options: ["have", "to have", "having", "has"], answer: 1 },
    { q: "The project is expected ___ completed soon.", options: ["be", "to be", "being", "been"], answer: 1 },
    { q: "He is known ___ a genius.", options: ["be", "to be", "being", "been"], answer: 1 },
    // Participle clauses
    { q: "___ the news, she cried.", options: ["Hear", "Heard", "Hearing", "Having heard"], answer: 3 },
    { q: "___ from the mountain, the view is stunning.", options: ["See", "Seen", "Seeing", "Having seen"], answer: 1 },
    { q: "___ all day, he was exhausted.", options: ["Work", "Worked", "Working", "Having worked"], answer: 3 },
    { q: "___ carefully, the instructions are clear.", options: ["Read", "Reading", "Having read", "Being read"], answer: 0 },
    // Reported speech advanced
    { q: "She asked if I ___ help her.", options: ["can", "could", "will", "may"], answer: 1 },
    { q: "He wondered where she ___.", options: ["is", "was", "has been", "will be"], answer: 1 },
    { q: "They demanded that he ___ immediately.", options: ["leave", "leaves", "left", "leaving"], answer: 0 },
    { q: "She insisted that I ___ with her.", options: ["go", "went", "going", "gone"], answer: 0 }
  ]
};

const GRID_SIZE = 10;
const SHIPS = [
  { name: 'Carrier', size: 5, color: '#e74c3c' },
  { name: 'Battleship', size: 4, color: '#9b59b6' },
  { name: 'Cruiser', size: 3, color: '#3498db' },
  { name: 'Submarine', size: 3, color: '#1abc9c' },
  { name: 'Destroyer', size: 2, color: '#f39c12' }
];

const WEAPONS = {
  simple: { name: 'Standard Shot', pattern: [[0, 0]], icon: 'üéØ' },
  big: { name: 'Big Bomb', pattern: [[0,0],[-1,0],[1,0],[0,-1],[0,1]], icon: 'üí£' },
  rain: { name: 'Missile Rain', pattern: 'random', icon: 'üåßÔ∏è' },
  nuclear: { name: 'Nuclear Strike', pattern: [[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[0,1],[1,-1],[1,0],[1,1]], icon: '‚ò¢Ô∏è' }
};

// Airdrop configuration
const AIRDROP_CONFIG = {
  startAfterTurn: 3,      // Start dropping after turn 3
  checkEveryTurns: 2,     // Check for drop every 2 turns
  baseChance: 0.35,       // 35% base chance
  maxDropsPerPlayer: 4    // Maximum drops per player per game
};

const PEER_CONFIG = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    {
      urls: 'turn:openrelay.metered.ca:80',
      username: 'openrelayproject',
      credential: 'openrelayproject'
    },
    {
      urls: 'turn:openrelay.metered.ca:443',
      username: 'openrelayproject',
      credential: 'openrelayproject'
    },
    {
      urls: 'turn:openrelay.metered.ca:443?transport=tcp',
      username: 'openrelayproject',
      credential: 'openrelayproject'
    }
  ]
};

const createEmptyGrid = () => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
const getRandomQuestion = (difficulty) => {
  const questions = grammarQuestions[difficulty];
  return questions[Math.floor(Math.random() * questions.length)];
};
const generateRainPattern = () => {
  const pattern = [];
  const used = new Set();
  while (pattern.length < 7) {
    const x = Math.floor(Math.random() * 5) - 2;
    const y = Math.floor(Math.random() * 5) - 2;
    const key = `${x},${y}`;
    if (!used.has(key)) { used.add(key); pattern.push([x, y]); }
  }
  return pattern;
};

function BattleshipESL() {
  const { useState, useEffect, useCallback, useRef } = React;

  const [gameMode, setGameMode] = useState(null);
  const [gamePhase, setGamePhase] = useState('menu');
  const [difficulty, setDifficulty] = useState('medium');
  const [winner, setWinner] = useState(null);

  const [player1, setPlayer1] = useState({
    grid: createEmptyGrid(), ships: [], tracking: createEmptyGrid(), received: createEmptyGrid(),
    weapons: { simple: Infinity, big: 0, rain: 0, nuclear: 0 }, gifts: [], shipsRemaining: 5, airdropsReceived: 0
  });
  const [player2, setPlayer2] = useState({
    grid: createEmptyGrid(), ships: [], tracking: createEmptyGrid(), received: createEmptyGrid(),
    weapons: { simple: Infinity, big: 0, rain: 0, nuclear: 0 }, gifts: [], shipsRemaining: 5, airdropsReceived: 0
  });

  const [opponentSetupReceived, setOpponentSetupReceived] = useState(false);
  const [currentShipIndex, setCurrentShipIndex] = useState(0);
  const [isHorizontal, setIsHorizontal] = useState(true);
  const [placedShips, setPlacedShips] = useState([]);
  const [selectedWeapon, setSelectedWeapon] = useState('simple');
  const [shotResults, setShotResults] = useState([]);
  const [extraTurn, setExtraTurn] = useState(false);
  const [sunkShip, setSunkShip] = useState(null);
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [answerResult, setAnswerResult] = useState(null);
  const [isWatchingQuestion, setIsWatchingQuestion] = useState(false);

  // Connection state
  const [myPeerId, setMyPeerId] = useState('');
  const [hostCode, setHostCode] = useState('');
  const [peerReady, setPeerReady] = useState(false);
  const [connected, setConnected] = useState(false);
  const [statusMsg, setStatusMsg] = useState('');
  const [debugLog, setDebugLog] = useState([]);
  const [isMyTurn, setIsMyTurn] = useState(false);
  const [waitingForOpponent, setWaitingForOpponent] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);

  // Animation states (inline, no overlay)
  const [hitCells, setHitCells] = useState([]);
  const [newAirdrop, setNewAirdrop] = useState(null);
  const [turnNotice, setTurnNotice] = useState(null);
  const [firingAnimation, setFiringAnimation] = useState(null);
  const [showFiringAnimation, setShowFiringAnimation] = useState(false);
  const [turnCount, setTurnCount] = useState(0);

  // Refs
  const peerRef = useRef(null);
  const connRef = useRef(null);
  const gameModeRef = useRef(null);
  const difficultyRef = useRef(difficulty);
  const player1Ref = useRef(player1);
  const player2Ref = useRef(player2);
  const waitingRef = useRef(false);
  const turnCountRef = useRef(0);

  useEffect(() => { gameModeRef.current = gameMode; }, [gameMode]);
  useEffect(() => { difficultyRef.current = difficulty; }, [difficulty]);
  useEffect(() => { player1Ref.current = player1; }, [player1]);
  useEffect(() => { player2Ref.current = player2; }, [player2]);
  useEffect(() => { waitingRef.current = waitingForOpponent; }, [waitingForOpponent]);
  useEffect(() => { turnCountRef.current = turnCount; }, [turnCount]);

  const log = (msg) => {
    console.log('[BSL]', msg);
    setDebugLog(prev => [...prev.slice(-14), msg]);
  };

  const copyToClipboard = async (text) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 2000);
    } catch (err) {
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 2000);
    }
  };

  const pasteFromClipboard = async () => {
    try {
      const text = await navigator.clipboard.readText();
      setHostCode(text.trim());
    } catch (err) {
      log('Paste failed - use manual paste');
    }
  };

  // Generate an airdrop for a player
  const trySpawnAirdrop = useCallback((playerData, setPlayerData, forOpponent = false) => {
    const { grid, received, gifts, airdropsReceived } = playerData;
    
    // Check limits
    if (airdropsReceived >= AIRDROP_CONFIG.maxDropsPerPlayer) return null;
    if (turnCountRef.current < AIRDROP_CONFIG.startAfterTurn) return null;
    if (turnCountRef.current % AIRDROP_CONFIG.checkEveryTurns !== 0) return null;
    if (Math.random() > AIRDROP_CONFIG.baseChance) return null;
    
    // Find empty cell (not ship, not hit, not already gift)
    const emptyCells = [];
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        if (grid[r][c] === null && received[r][c] === null && !gifts.find(g => g.row === r && g.col === c)) {
          emptyCells.push([r, c]);
        }
      }
    }
    
    if (emptyCells.length === 0) return null;
    
    const [row, col] = emptyCells[Math.floor(Math.random() * emptyCells.length)];
    const types = ['big', 'rain', 'nuclear'];
    const weapon = types[Math.floor(Math.random() * types.length)];
    const newGift = { row, col, weapon, isNew: true };
    
    setPlayerData(p => ({
      ...p,
      gifts: [...p.gifts, newGift],
      airdropsReceived: p.airdropsReceived + 1
    }));
    
    // Clear "new" flag after animation
    setTimeout(() => {
      setPlayerData(p => ({
        ...p,
        gifts: p.gifts.map(g => g.row === row && g.col === col ? { ...g, isNew: false } : g)
      }));
    }, 2000);
    
    return newGift;
  }, []);

  // Send message
  const sendMsg = useCallback((msg) => {
    if (connRef.current && connRef.current.open) {
      connRef.current.send(msg);
      return true;
    }
    return false;
  }, []);

  // Handle incoming messages
  const onMessage = useCallback((data) => {
    log('RECV: ' + data.type);
    const isHost = gameModeRef.current === 'online-host';

    if (data.type === 'settings') {
      setDifficulty(data.difficulty);
      setGamePhase('setup');
    }
    else if (data.type === 'setup-complete') {
      if (isHost) {
        setPlayer2(p => ({ ...p, grid: data.grid, ships: data.ships }));
      } else {
        setPlayer1(p => ({ ...p, grid: data.grid, ships: data.ships }));
      }
      setOpponentSetupReceived(true);
      if (waitingRef.current) {
        setWaitingForOpponent(false);
        setGamePhase('battle');
      }
    }
    else if (data.type === 'shot') {
      handleIncomingShot(data);
    }
    else if (data.type === 'shot-result') {
      handleShotResult(data);
    }
    else if (data.type === 'answer-selected') {
      setSelectedAnswer(data.idx);
    }
    else if (data.type === 'question-answered') {
      setAnswerResult(data.correct);
      setTimeout(() => {
        setWaitingForOpponent(false);
        setIsWatchingQuestion(false);
        setCurrentQuestion(null);
        setSelectedAnswer(null);
        setAnswerResult(null);
        setShotResults([]);
        setExtraTurn(false);
        setSunkShip(null);
        setIsMyTurn(data.correct && data.gotHit ? false : true);
        setGamePhase('battle');
      }, 1500);
    }
    else if (data.type === 'question-retry') {
      setSelectedAnswer(null);
      setAnswerResult(null);
    }
    else if (data.type === 'new-question') {
      setCurrentQuestion(data.question);
      setSelectedAnswer(null);
      setAnswerResult(null);
    }
    else if (data.type === 'airdrop') {
      // Opponent got an airdrop on their grid (enemy waters for us)
      const setOpp = isHost ? setPlayer2 : setPlayer1;
      setOpp(p => ({
        ...p,
        gifts: [...p.gifts, { row: data.row, col: data.col, weapon: data.weapon, isNew: true }],
        airdropsReceived: p.airdropsReceived + 1
      }));
      setTimeout(() => {
        setOpp(p => ({
          ...p,
          gifts: p.gifts.map(g => g.row === data.row && g.col === data.col ? { ...g, isNew: false } : g)
        }));
      }, 2000);
    }
  }, []);

  const onConnectionOpen = useCallback((conn, isHost) => {
    log('*** CONNECTION OPEN ***');
    connRef.current = conn;
    setConnected(true);
    setStatusMsg('Connected!');
    
    if (isHost) {
      setTimeout(() => {
        conn.send({ type: 'settings', difficulty: difficultyRef.current });
        setGamePhase('setup');
      }, 300);
    }
  }, []);

  const setupConnection = useCallback((conn, isHost) => {
    log('Setting up connection...');
    connRef.current = conn;
    
    conn.on('open', () => onConnectionOpen(conn, isHost));
    conn.on('data', onMessage);
    conn.on('close', () => {
      log('Connection closed');
      setConnected(false);
      setStatusMsg('Disconnected');
    });
    conn.on('error', (err) => {
      log('Conn error: ' + (err.type || err));
      setStatusMsg('Connection error');
    });

    if (conn.open) {
      onConnectionOpen(conn, isHost);
    }
  }, [onMessage, onConnectionOpen]);

  const startHost = useCallback(() => {
    setGameMode('online-host');
    setStatusMsg('Creating...');
    setIsMyTurn(true);
    log('Starting host...');

    const peer = new Peer(null, { debug: 2, config: PEER_CONFIG });
    peerRef.current = peer;

    peer.on('open', (id) => {
      log('Peer ready: ' + id.substring(0, 8) + '...');
      setMyPeerId(id);
      setPeerReady(true);
      setStatusMsg('Share code with opponent');
    });

    peer.on('connection', (conn) => {
      log('Incoming connection!');
      setStatusMsg('Opponent connecting...');
      setupConnection(conn, true);
    });

    peer.on('error', (err) => {
      log('Peer error: ' + err.type);
      setStatusMsg('Error: ' + err.type);
    });

    peer.on('disconnected', () => {
      if (peerRef.current && !peerRef.current.destroyed) {
        peerRef.current.reconnect();
      }
    });
  }, [setupConnection]);

  const startJoin = useCallback(() => {
    setGameMode('online-joiner');
    setStatusMsg('Initializing...');
    setIsMyTurn(false);
    log('Starting joiner...');

    const peer = new Peer(null, { debug: 2, config: PEER_CONFIG });
    peerRef.current = peer;

    peer.on('open', (id) => {
      log('Peer ready: ' + id.substring(0, 8) + '...');
      setMyPeerId(id);
      setPeerReady(true);
      setStatusMsg('Enter code & connect');
    });

    peer.on('error', (err) => {
      log('Peer error: ' + err.type);
      if (err.type === 'peer-unavailable') {
        setStatusMsg('Invalid code - check and retry');
      } else {
        setStatusMsg('Error: ' + err.type);
      }
    });

    peer.on('disconnected', () => {
      if (peerRef.current && !peerRef.current.destroyed) {
        peerRef.current.reconnect();
      }
    });
  }, []);

  const doConnect = useCallback(() => {
    const code = hostCode.trim();
    if (!code) { setStatusMsg('Enter the code first'); return; }
    if (!peerRef.current || !peerReady) { setStatusMsg('Not ready - wait...'); return; }

    log('Connecting to: ' + code.substring(0, 8) + '...');
    setStatusMsg('Connecting...');

    const conn = peerRef.current.connect(code, { reliable: true, serialization: 'json' });
    setupConnection(conn, false);

    setTimeout(() => {
      if (!connected && connRef.current && !connRef.current.open) {
        log('Connection timeout');
        setStatusMsg('Timeout - try again');
      }
    }, 20000);
  }, [hostCode, peerReady, setupConnection, connected]);

  const goBack = useCallback(() => {
    if (connRef.current) { connRef.current.close(); connRef.current = null; }
    if (peerRef.current) { peerRef.current.destroy(); peerRef.current = null; }
    setGameMode(null);
    setMyPeerId('');
    setHostCode('');
    setPeerReady(false);
    setConnected(false);
    setStatusMsg('');
    setDebugLog([]);
  }, []);

  // Handle incoming shot - NO OVERLAY
  const handleIncomingShot = (data) => {
    const { row, col, weapon } = data;
    const isHost = gameModeRef.current === 'online-host';
    const pattern = weapon === 'rain' ? generateRainPattern() : WEAPONS[weapon].pattern;
    const results = [];
    let gotHit = false;

    setWaitingForOpponent(false);

    const myPlayer = isHost ? player1Ref.current : player2Ref.current;
    const setMyPlayer = isHost ? setPlayer1 : setPlayer2;

    const newReceived = myPlayer.received.map(r => [...r]);
    let shipsRemaining = myPlayer.shipsRemaining;
    let sunkShipName = null;
    const myShips = myPlayer.ships.map(s => ({ ...s, cells: [...s.cells] }));
    const myGifts = [...(myPlayer.gifts || [])];
    let collectedGift = null;

    const targetCells = pattern.map(([dx, dy]) => [row + dx, col + dy]);

    targetCells.forEach(([r, c]) => {
      if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && newReceived[r][c] === null) {
        const cell = myPlayer.grid[r][c];
        const giftIdx = myGifts.findIndex(g => g.row === r && g.col === c);
        if (giftIdx !== -1 && !collectedGift) {
          collectedGift = myGifts[giftIdx];
          myGifts.splice(giftIdx, 1);
        }
        if (cell && cell.ship !== undefined) {
          newReceived[r][c] = 'hit';
          gotHit = true;
          results.push({ row: r, col: c, result: 'hit' });
          const ship = myShips[cell.ship];
          if (ship.cells.every(([sr, sc]) => newReceived[sr][sc] === 'hit') && !ship.sunk) {
            ship.sunk = true;
            shipsRemaining--;
            sunkShipName = SHIPS[cell.ship].name;
          }
        } else {
          newReceived[r][c] = 'miss';
          results.push({ row: r, col: c, result: 'miss' });
        }
      }
    });

    // Show hit animation inline
    setHitCells(results.map(r => ({ ...r, timestamp: Date.now() })));
    setTurnNotice(gotHit ? { type: 'hit', ship: sunkShipName } : { type: 'miss' });
    
    setMyPlayer(p => ({ ...p, received: newReceived, shipsRemaining, ships: myShips, gifts: myGifts }));

    const question = shipsRemaining > 0 ? getRandomQuestion(difficultyRef.current) : null;
    sendMsg({ type: 'shot-result', results, gotHit, sunkShip: sunkShipName, shipsRemaining, gameOver: shipsRemaining === 0, question, collectedGift });

    // Clear animation and proceed
    setTimeout(() => {
      setHitCells([]);
      setTurnNotice(null);
      if (shipsRemaining === 0) {
        setWinner(isHost ? 2 : 1);
        setGamePhase('gameover');
      } else {
        setCurrentQuestion(question);
        setIsWatchingQuestion(true);
        setGamePhase('question');
      }
    }, 1500);
  };

  const handleShotResult = (data) => {
    const isHost = gameModeRef.current === 'online-host';
    setWaitingForOpponent(false);
    setShotResults(data.results);
    const setMyPlayer = isHost ? setPlayer1 : setPlayer2;

    setMyPlayer(p => {
      const newTracking = p.tracking.map(r => [...r]);
      data.results.forEach(({ row, col, result }) => { newTracking[row][col] = result; });
      const newWeapons = { ...p.weapons };
      if (data.collectedGift) newWeapons[data.collectedGift.weapon] = (newWeapons[data.collectedGift.weapon] || 0) + 1;
      return { ...p, tracking: newTracking, weapons: newWeapons };
    });

    if (data.sunkShip) setSunkShip(data.sunkShip);
    if (data.gameOver) {
      setWinner(isHost ? 1 : 2);
      setGamePhase('gameover');
    } else {
      setExtraTurn(data.gotHit);
      setCurrentQuestion(data.question);
      setIsWatchingQuestion(false);
      setGamePhase('question');
    }
  };

  const canPlaceShip = (grid, row, col, size, horiz) => {
    for (let i = 0; i < size; i++) {
      const r = horiz ? row : row + i;
      const c = horiz ? col + i : col;
      if (r >= GRID_SIZE || c >= GRID_SIZE || grid[r][c] !== null) return false;
    }
    return true;
  };

  const placeShip = (row, col) => {
    if (currentShipIndex >= SHIPS.length) return;
    const ship = SHIPS[currentShipIndex];
    const isHost = gameMode === 'online-host';
    const currentGrid = isHost ? player1.grid : player2.grid;
    const grid = currentGrid.map(r => [...r]);

    if (!canPlaceShip(grid, row, col, ship.size, isHorizontal)) return;

    const shipCells = [];
    for (let i = 0; i < ship.size; i++) {
      const r = isHorizontal ? row : row + i;
      const c = isHorizontal ? col + i : col;
      grid[r][c] = { ship: currentShipIndex, part: i };
      shipCells.push([r, c]);
    }

    const newShip = { ...ship, cells: shipCells, sunk: false };
    const newPlacedShips = [...placedShips, newShip];
    setPlacedShips(newPlacedShips);

    if (isHost) setPlayer1(p => ({ ...p, grid, ships: newPlacedShips }));
    else setPlayer2(p => ({ ...p, grid, ships: newPlacedShips }));

    if (currentShipIndex < SHIPS.length - 1) setCurrentShipIndex(currentShipIndex + 1);
    else completeSetup(grid, newPlacedShips);
  };

  const completeSetup = (grid, ships) => {
    // No initial gifts - they spawn during gameplay
    const isHost = gameMode === 'online-host';
    if (isHost) setPlayer1(p => ({ ...p, grid, ships, gifts: [], airdropsReceived: 0 }));
    else setPlayer2(p => ({ ...p, grid, ships, gifts: [], airdropsReceived: 0 }));

    sendMsg({ type: 'setup-complete', grid, ships });

    if (opponentSetupReceived) setGamePhase('battle');
    else setWaitingForOpponent(true);
  };

  const randomPlaceShips = () => {
    const grid = createEmptyGrid();
    const ships = [];

    for (let i = 0; i < SHIPS.length; i++) {
      const ship = SHIPS[i];
      let placed = false, attempts = 0;
      while (!placed && attempts < 500) {
        const horiz = Math.random() > 0.5;
        const row = Math.floor(Math.random() * GRID_SIZE);
        const col = Math.floor(Math.random() * GRID_SIZE);
        if (canPlaceShip(grid, row, col, ship.size, horiz)) {
          const cells = [];
          for (let j = 0; j < ship.size; j++) {
            const r = horiz ? row : row + j;
            const c = horiz ? col + j : col;
            grid[r][c] = { ship: i, part: j };
            cells.push([r, c]);
          }
          ships.push({ ...ship, cells, sunk: false });
          placed = true;
        }
        attempts++;
      }
    }

    const isHost = gameMode === 'online-host';
    if (isHost) setPlayer1(p => ({ ...p, grid, ships }));
    else setPlayer2(p => ({ ...p, grid, ships }));
    completeSetup(grid, ships);
  };

  const fireWeapon = (row, col) => {
    if (!isMyTurn || showFiringAnimation) return;
    const isHost = gameMode === 'online-host';
    const attacker = isHost ? player1 : player2;
    if (selectedWeapon !== 'simple' && attacker.weapons[selectedWeapon] <= 0) return;
    const tracking = isHost ? player1.tracking : player2.tracking;
    if (tracking[row][col] !== null) return;

    const pattern = selectedWeapon === 'rain' ? generateRainPattern() : WEAPONS[selectedWeapon].pattern;
    const targets = pattern.map(([dx, dy]) => [row + dx, col + dy]).filter(([r, c]) => r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE);

    setFiringAnimation({ weapon: selectedWeapon, targets, phase: 'launch' });
    setShowFiringAnimation(true);
    setTimeout(() => setFiringAnimation(p => ({ ...p, phase: 'travel' })), 300);
    setTimeout(() => setFiringAnimation(p => ({ ...p, phase: 'impact' })), 800);

    setTimeout(() => {
      setShowFiringAnimation(false);
      setFiringAnimation(null);
      const newTurn = turnCount + 1;
      setTurnCount(newTurn);
      
      sendMsg({ type: 'shot', row, col, weapon: selectedWeapon });
      setIsMyTurn(false);
      setWaitingForOpponent(true);

      if (selectedWeapon !== 'simple') {
        const setP = isHost ? setPlayer1 : setPlayer2;
        setP(p => ({ ...p, weapons: { ...p.weapons, [selectedWeapon]: p.weapons[selectedWeapon] - 1 } }));
      }

      // Try to spawn airdrop for attacker after firing
      setTimeout(() => {
        const myPlayerData = isHost ? player1Ref.current : player2Ref.current;
        const setMyPlayer = isHost ? setPlayer1 : setPlayer2;
        const drop = trySpawnAirdrop(myPlayerData, setMyPlayer);
        if (drop) {
          sendMsg({ type: 'airdrop', row: drop.row, col: drop.col, weapon: drop.weapon });
          setNewAirdrop(drop);
          setTimeout(() => setNewAirdrop(null), 2000);
        }
      }, 500);
    }, 1300);
  };

  const handleAnswer = (idx) => {
    if (isWatchingQuestion) return;
    setSelectedAnswer(idx);
    const correct = idx === currentQuestion.answer;
    setAnswerResult(correct);
    sendMsg({ type: 'answer-selected', idx });

    setTimeout(() => {
      if (correct) {
        sendMsg({ type: 'question-answered', correct: true, gotHit: extraTurn });
        setIsMyTurn(extraTurn);
        setCurrentQuestion(null);
        setSelectedAnswer(null);
        setAnswerResult(null);
        setShotResults([]);
        setExtraTurn(false);
        setSunkShip(null);
        setIsWatchingQuestion(false);
        setGamePhase('battle');
      } else {
        sendMsg({ type: 'question-retry' });
        const newQ = getRandomQuestion(difficulty);
        setCurrentQuestion(newQ);
        setSelectedAnswer(null);
        setAnswerResult(null);
        sendMsg({ type: 'new-question', question: newQ });
      }
    }, 1500);
  };

  const renderCell = (row, col, isOwn, playerData, isSetup = false, trackingData = null) => {
    const cell = playerData.grid[row][col];
    const hitData = isOwn ? playerData.received : trackingData;
    const hit = hitData ? hitData[row][col] : null;
    const gift = playerData.gifts?.find(g => g.row === row && g.col === col);
    const isNewHit = hitCells.some(h => h.row === row && h.col === col);
    const hitResult = hitCells.find(h => h.row === row && h.col === col)?.result;
    const isFiring = showFiringAnimation && firingAnimation?.targets.some(([r, c]) => r === row && c === col);
    const isNewAirdrop = gift?.isNew;

    let cls = 'cell';
    let content = '';

    if (isOwn) {
      if (cell?.ship !== undefined) {
        return (
          <div key={`${row}-${col}`} className={`cell ship ${isNewHit ? 'new-hit' : ''}`} style={{ backgroundColor: SHIPS[cell.ship].color }}>
            {(hit === 'hit' || hitResult === 'hit') && 'üî•'}
            {gift && <span className={isNewAirdrop ? 'airdrop-new' : ''}>üéÅ</span>}
          </div>
        );
      }
      if (hit === 'miss' || hitResult === 'miss') { cls += ' miss'; content = 'üí®'; }
      if (isNewHit) cls += ' new-hit';
      if (gift && !hit) content = <span className={isNewAirdrop ? 'airdrop-new' : ''}>üéÅ</span>;
    } else {
      if (hit === 'hit') { cls += ' hit'; content = 'üí•'; }
      else if (hit === 'miss') { cls += ' miss'; content = 'üí®'; }
      else if (gift) { cls += ' enemy gift-cell'; content = <span className={isNewAirdrop ? 'airdrop-new' : ''}>üéÅ</span>; }
      else cls += ' enemy';
      if (isFiring) cls += ` firing-${firingAnimation.phase}`;
    }

    const onClick = () => {
      if (isSetup) placeShip(row, col);
      else if (!isOwn && !hit && gamePhase === 'battle' && isMyTurn && !showFiringAnimation) fireWeapon(row, col);
    };

    return <div key={`${row}-${col}`} className={cls} onClick={onClick}>{content}</div>;
  };

  const renderGrid = (isOwn, playerData, isSetup = false, trackingData = null) => (
    <div className="grid-wrapper">
      <div className="grid-labels-top">
        <div className="corner"></div>
        {Array.from({ length: GRID_SIZE }, (_, i) => <div key={i} className="label">{i + 1}</div>)}
      </div>
      <div className="grid-body">
        <div className="grid-labels-side">
          {Array.from({ length: GRID_SIZE }, (_, i) => <div key={i} className="label">{String.fromCharCode(65 + i)}</div>)}
        </div>
        <div className="grid">
          {Array.from({ length: GRID_SIZE }, (_, row) =>
            Array.from({ length: GRID_SIZE }, (_, col) => renderCell(row, col, isOwn, playerData, isSetup, trackingData))
          )}
        </div>
      </div>
    </div>
  );

  const isHost = gameMode === 'online-host';

  const styles = `
    .game-container { min-height:100vh; background:linear-gradient(135deg,#1a1a2e,#16213e,#0f3460); color:#fff; font-family:'Segoe UI',system-ui,sans-serif; padding:20px; display:flex; flex-direction:column; align-items:center; }
    .header { text-align:center; margin-bottom:20px; }
    .title { font-size:2.2rem; font-weight:800; background:linear-gradient(90deg,#00d9ff,#00ff88); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
    .subtitle { color:#8892b0; font-size:0.9rem; }
    .menu-container { display:flex; justify-content:center; align-items:center; flex:1; width:100%; }
    .menu-panel { background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:20px; padding:30px; width:100%; max-width:420px; }
    .menu-title { text-align:center; font-size:1.4rem; margin-bottom:25px; color:#00d9ff; }
    .menu-btn { width:100%; padding:14px; margin:8px 0; border:none; border-radius:10px; font-size:1rem; cursor:pointer; background:linear-gradient(135deg,#334155,#1e293b); color:#fff; transition:transform 0.2s; }
    .menu-btn:hover { transform:translateY(-2px); }
    .menu-btn.primary { background:linear-gradient(135deg,#00d9ff,#00ff88); color:#1a1a2e; font-weight:bold; }
    .menu-btn.back { background:transparent; border:2px solid #334155; margin-top:15px; }
    .menu-btn:disabled { opacity:0.5; cursor:not-allowed; transform:none; }
    .conn-panel { margin-top:20px; padding:20px; background:rgba(0,0,0,0.3); border-radius:12px; }
    .conn-title { font-size:1.1rem; color:#00d9ff; margin-bottom:12px; text-align:center; }
    .diff-selector { margin-bottom:18px; }
    .diff-label { display:block; text-align:center; margin-bottom:8px; color:#8892b0; font-size:0.9rem; }
    .diff-btns { display:flex; gap:8px; justify-content:center; }
    .diff-btn { padding:8px 16px; border:2px solid #334155; background:transparent; color:#fff; border-radius:8px; cursor:pointer; }
    .diff-btn:hover,.diff-btn.active { border-color:#00d9ff; background:rgba(0,217,255,0.15); }
    .code-display { background:rgba(0,0,0,0.5); padding:14px; border-radius:8px; font-family:monospace; font-size:0.7rem; word-break:break-all; margin:10px 0; text-align:center; cursor:pointer; border:2px solid transparent; }
    .code-display:hover { border-color:#00d9ff; }
    .code-display.copied { border-color:#00ff88; background:rgba(0,255,136,0.1); }
    .copy-hint { font-size:0.7rem; color:#8892b0; text-align:center; }
    .copy-hint.success { color:#00ff88; }
    .input-row { display:flex; gap:8px; margin:8px 0; }
    .code-input { flex:1; padding:12px; border:2px solid #334155; border-radius:8px; background:rgba(0,0,0,0.4); color:#fff; font-size:0.8rem; font-family:monospace; }
    .code-input:focus { outline:none; border-color:#00d9ff; }
    .paste-btn { padding:12px 16px; border:2px solid #334155; border-radius:8px; background:rgba(0,0,0,0.3); color:#fff; cursor:pointer; font-size:1rem; }
    .paste-btn:hover { border-color:#00d9ff; background:rgba(0,217,255,0.1); }
    .status-box { display:flex; align-items:center; justify-content:center; gap:10px; margin-top:12px; padding:10px; background:rgba(0,0,0,0.2); border-radius:8px; font-size:0.9rem; }
    .status-dot { width:10px; height:10px; border-radius:50%; background:#ef4444; }
    .status-dot.ready { background:#fbbf24; animation:pulse-dot 1s infinite; }
    .status-dot.connected { background:#22c55e; box-shadow:0 0 8px #22c55e; }
    @keyframes pulse-dot { 0%,100%{opacity:1} 50%{opacity:0.5} }
    .debug-log { margin-top:12px; padding:8px; background:rgba(0,0,0,0.4); border-radius:6px; font-size:0.6rem; font-family:monospace; max-height:120px; overflow-y:auto; }
    .debug-log div { padding:1px 0; color:#8892b0; }
    .setup-container { display:flex; flex-direction:column; align-items:center; max-width:600px; }
    .setup-header { text-align:center; margin-bottom:15px; }
    .player-ind { font-size:1.3rem; font-weight:bold; color:#00d9ff; margin-bottom:12px; }
    .ship-info { display:flex; align-items:center; gap:12px; margin-bottom:12px; }
    .ship-preview { display:flex; gap:2px; }
    .ship-cell { width:22px; height:22px; border-radius:3px; }
    .setup-controls { display:flex; gap:8px; }
    .ctrl-btn { padding:8px 14px; border:2px solid #334155; background:transparent; color:#fff; border-radius:8px; cursor:pointer; }
    .ctrl-btn:hover,.ctrl-btn.active { border-color:#00d9ff; background:rgba(0,217,255,0.1); }
    .grid-wrapper { display:inline-block; }
    .grid-labels-top { display:flex; }
    .corner { width:28px; height:28px; }
    .label { width:32px; height:28px; display:flex; align-items:center; justify-content:center; font-weight:bold; color:#8892b0; font-size:0.75rem; }
    .grid-body { display:flex; }
    .grid-labels-side { display:flex; flex-direction:column; }
    .grid-labels-side .label { width:28px; height:32px; }
    .grid { display:grid; grid-template-columns:repeat(10,32px); gap:2px; background:rgba(0,0,0,0.3); padding:4px; border-radius:8px; }
    .cell { width:32px; height:32px; background:rgba(0,100,150,0.3); border-radius:3px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:1rem; transition:all 0.2s; }
    .cell:hover { background:rgba(0,200,255,0.3); }
    .cell.ship { cursor:default; }
    .cell.enemy:hover { background:rgba(255,100,100,0.4); }
    .cell.hit { background:rgba(255,100,100,0.6); }
    .cell.miss { background:rgba(100,100,100,0.4); }
    .cell.gift-cell { background:rgba(255,200,0,0.3); border:2px solid #fbbf24; }
    .cell.new-hit { animation:hit-flash 0.5s ease-out 3; }
    @keyframes hit-flash { 0%,100%{background:rgba(255,100,100,0.6)} 50%{background:rgba(255,255,100,0.9)} }
    .cell.firing-launch { background:rgba(255,200,0,0.4); }
    .cell.firing-travel { background:rgba(255,150,0,0.5); }
    .cell.firing-impact { background:rgba(255,100,0,0.7); }
    .airdrop-new { animation:airdrop-drop 1s ease-out, airdrop-glow 0.5s ease-in-out infinite alternate; }
    @keyframes airdrop-drop { 0%{transform:translateY(-30px) scale(2);opacity:0} 60%{transform:translateY(5px) scale(1);opacity:1} 100%{transform:translateY(0) scale(1)} }
    @keyframes airdrop-glow { 0%{filter:brightness(1)} 100%{filter:brightness(1.5)} }
    .battle-container { display:flex; flex-direction:column; align-items:center; width:100%; max-width:1000px; }
    .battle-header { text-align:center; margin-bottom:12px; }
    .turn-ind { font-size:1.2rem; font-weight:bold; padding:10px 18px; border-radius:10px; display:inline-block; }
    .turn-ind.my { color:#00ff88; background:rgba(0,255,136,0.15); border:2px solid #00ff88; }
    .turn-ind.wait { color:#fbbf24; background:rgba(251,191,36,0.15); border:2px solid #fbbf24; }
    .turn-notice { margin-top:8px; font-size:1rem; font-weight:bold; animation:notice-pop 0.3s ease-out; }
    .turn-notice.hit { color:#ef4444; }
    .turn-notice.miss { color:#8892b0; }
    @keyframes notice-pop { 0%{transform:scale(0.5);opacity:0} 100%{transform:scale(1);opacity:1} }
    .airdrop-notice { position:fixed; top:20%; left:50%; transform:translateX(-50%); background:linear-gradient(135deg,#f39c12,#e74c3c); padding:15px 25px; border-radius:12px; font-size:1.2rem; font-weight:bold; z-index:50; animation:airdrop-notice 2s ease-out forwards; }
    @keyframes airdrop-notice { 0%{opacity:0;transform:translateX(-50%) translateY(-20px)} 20%{opacity:1;transform:translateX(-50%) translateY(0)} 80%{opacity:1} 100%{opacity:0} }
    .grids { display:flex; justify-content:center; gap:25px; flex-wrap:wrap; }
    .grid-section { text-align:center; }
    .grid-title { font-size:1rem; margin-bottom:6px; color:#00d9ff; font-weight:bold; }
    .ships-status { display:flex; flex-wrap:wrap; gap:4px; justify-content:center; margin-top:8px; }
    .ship-stat { padding:3px 6px; background:rgba(0,150,100,0.3); border-radius:4px; font-size:0.65rem; }
    .ship-stat.sunk { background:rgba(200,50,50,0.5); text-decoration:line-through; }
    .weapons-panel { margin-top:15px; text-align:center; }
    .weapons-title { font-size:1rem; margin-bottom:8px; color:#00d9ff; }
    .weapons-grid { display:flex; justify-content:center; gap:6px; flex-wrap:wrap; }
    .weapon-btn { display:flex; flex-direction:column; align-items:center; padding:6px 10px; border:2px solid #334155; background:rgba(0,0,0,0.3); color:#fff; border-radius:8px; cursor:pointer; min-width:65px; }
    .weapon-btn:hover:not(:disabled) { border-color:#00d9ff; }
    .weapon-btn.selected { border-color:#00ff88; background:rgba(0,255,136,0.2); }
    .weapon-btn:disabled { opacity:0.4; cursor:not-allowed; }
    .weapon-icon { font-size:1.2rem; }
    .weapon-name { font-size:0.65rem; }
    .weapon-count { font-size:0.7rem; color:#00d9ff; font-weight:bold; }
    .question-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center; z-index:100; }
    .question-modal { background:linear-gradient(135deg,#1a1a2e,#16213e); border:2px solid #00d9ff; border-radius:16px; padding:25px; max-width:450px; width:90%; text-align:center; }
    .shot-result { margin-bottom:15px; padding:12px; border-radius:8px; background:rgba(100,100,100,0.3); }
    .shot-result.hit { background:rgba(255,100,100,0.3); border:1px solid #e74c3c; }
    .shot-result-text { font-size:1.3rem; font-weight:bold; }
    .sunk-ann { color:#f39c12; font-weight:bold; margin-top:8px; }
    .extra-notice { color:#00ff88; font-weight:bold; margin-top:8px; }
    .watching-ind { background:rgba(0,217,255,0.2); border:2px solid #00d9ff; border-radius:8px; padding:12px; margin-bottom:15px; color:#00d9ff; }
    .q-header { font-size:1.1rem; color:#00d9ff; margin-bottom:12px; }
    .q-text { font-size:1.2rem; margin-bottom:15px; }
    .options { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .opt-btn { padding:12px; border:2px solid #334155; background:rgba(0,0,0,0.3); color:#fff; border-radius:8px; font-size:0.95rem; cursor:pointer; }
    .opt-btn:hover:not(:disabled) { border-color:#00d9ff; }
    .opt-btn.selected { border-color:#f39c12; background:rgba(243,156,18,0.2); }
    .opt-btn.correct { border-color:#22c55e; background:rgba(34,197,94,0.3); }
    .opt-btn.incorrect { border-color:#ef4444; background:rgba(239,68,68,0.3); }
    .feedback { margin-top:12px; font-size:1.1rem; font-weight:bold; }
    .feedback.correct { color:#22c55e; }
    .feedback.incorrect { color:#ef4444; }
    .gameover-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:100; }
    .gameover-content { text-align:center; }
    .gameover-title { font-size:2.5rem; margin-bottom:15px; }
    .gameover-btn { padding:12px 35px; font-size:1.1rem; border:none; border-radius:10px; background:linear-gradient(135deg,#00d9ff,#00ff88); color:#1a1a2e; font-weight:bold; cursor:pointer; }
    .waiting-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; z-index:50; }
    .waiting-content { text-align:center; }
    .spinner { width:40px; height:40px; border:4px solid rgba(255,255,255,0.2); border-top-color:#00d9ff; border-radius:50%; animation:spin 1s linear infinite; margin:0 auto 15px; }
    @keyframes spin { to{transform:rotate(360deg)} }
    @media(max-width:768px) { .title{font-size:1.5rem} .grids{flex-direction:column;align-items:center} .grid{grid-template-columns:repeat(10,28px)} .cell{width:28px;height:28px;font-size:0.85rem} .label{width:28px;height:24px;font-size:0.65rem} .grid-labels-side .label{width:24px;height:28px} .corner{width:24px;height:24px} }
  `;

  return (
    <div className="game-container">
      <style>{styles}</style>
      <div className="header">
        <h1 className="title">‚öì Battleship ESL ‚öì</h1>
        <p className="subtitle">Naval Combat Grammar Challenge</p>
      </div>

      {/* Airdrop notification */}
      {newAirdrop && (
        <div className="airdrop-notice">üéÅ AIRDROP! {WEAPONS[newAirdrop.weapon].icon} {WEAPONS[newAirdrop.weapon].name}</div>
      )}

      {/* MENU */}
      {gamePhase === 'menu' && (
        <div className="menu-container">
          <div className="menu-panel">
            <div className="menu-title">üéÆ Online Multiplayer</div>

            {!gameMode && (
              <>
                <button className="menu-btn primary" onClick={startHost}>üåê Host Game</button>
                <button className="menu-btn" onClick={startJoin}>üîó Join Game</button>
              </>
            )}

            {gameMode === 'online-host' && (
              <div className="conn-panel">
                <div className="conn-title">üåê Hosting Game</div>
                <div className="diff-selector">
                  <span className="diff-label">Difficulty</span>
                  <div className="diff-btns">
                    <button className={`diff-btn ${difficulty==='easy'?'active':''}`} onClick={()=>setDifficulty('easy')}>Easy</button>
                    <button className={`diff-btn ${difficulty==='medium'?'active':''}`} onClick={()=>setDifficulty('medium')}>Medium</button>
                    <button className={`diff-btn ${difficulty==='hard'?'active':''}`} onClick={()=>setDifficulty('hard')}>Hard</button>
                  </div>
                </div>
                <div style={{textAlign:'center',marginBottom:'8px',fontSize:'0.9rem'}}>Your game code:</div>
                <div className={`code-display ${copySuccess?'copied':''}`} onClick={()=>myPeerId&&copyToClipboard(myPeerId)}>
                  {myPeerId || 'Generating...'}
                </div>
                <div className={`copy-hint ${copySuccess?'success':''}`}>{copySuccess ? '‚úì Copied!' : 'Tap to copy'}</div>
                <div className="status-box">
                  <div className={`status-dot ${connected?'connected':peerReady?'ready':''}`}></div>
                  <span>{statusMsg}</span>
                </div>
                <div className="debug-log">
                  {debugLog.map((l, i) => <div key={i}>{l}</div>)}
                </div>
                <button className="menu-btn back" onClick={goBack}>‚Üê Back</button>
              </div>
            )}

            {gameMode === 'online-joiner' && (
              <div className="conn-panel">
                <div className="conn-title">üîó Join Game</div>
                <div style={{textAlign:'center',marginBottom:'8px',fontSize:'0.9rem'}}>Enter host's code:</div>
                <div className="input-row">
                  <input className="code-input" type="text" placeholder="Paste code here" value={hostCode} onChange={(e) => setHostCode(e.target.value)} />
                  <button className="paste-btn" onClick={pasteFromClipboard} title="Paste">üìã</button>
                </div>
                <button className="menu-btn primary" onClick={doConnect} disabled={!peerReady || !hostCode.trim() || connected}>
                  {connected ? 'Connected!' : peerReady ? 'Connect' : 'Initializing...'}
                </button>
                <div className="status-box">
                  <div className={`status-dot ${connected?'connected':peerReady?'ready':''}`}></div>
                  <span>{statusMsg}</span>
                </div>
                <div className="debug-log">
                  {debugLog.map((l, i) => <div key={i}>{l}</div>)}
                </div>
                <button className="menu-btn back" onClick={goBack}>‚Üê Back</button>
              </div>
            )}
          </div>
        </div>
      )}

      {/* SETUP */}
      {gamePhase === 'setup' && (
        <div className="setup-container">
          <div className="setup-header">
            <div className="player-ind">Place Your Ships</div>
            {currentShipIndex < SHIPS.length && (
              <div className="ship-info">
                <div className="ship-preview">
                  {Array.from({length:SHIPS[currentShipIndex].size},(_,i)=>(
                    <div key={i} className="ship-cell" style={{backgroundColor:SHIPS[currentShipIndex].color}}/>
                  ))}
                </div>
                <div>
                  <div style={{fontWeight:'bold'}}>{SHIPS[currentShipIndex].name}</div>
                  <div style={{fontSize:'0.8rem',color:'#8892b0'}}>Size: {SHIPS[currentShipIndex].size}</div>
                </div>
              </div>
            )}
            <div className="setup-controls">
              <button className={`ctrl-btn ${isHorizontal?'active':''}`} onClick={()=>setIsHorizontal(true)}>Horizontal</button>
              <button className={`ctrl-btn ${!isHorizontal?'active':''}`} onClick={()=>setIsHorizontal(false)}>Vertical</button>
              <button className="ctrl-btn" onClick={randomPlaceShips}>Random</button>
            </div>
          </div>
          {renderGrid(true, isHost ? player1 : player2, true)}
        </div>
      )}

      {waitingForOpponent && gamePhase === 'setup' && (
        <div className="waiting-overlay">
          <div className="waiting-content">
            <div className="spinner"></div>
            <div>Waiting for opponent...</div>
          </div>
        </div>
      )}

      {/* BATTLE */}
      {gamePhase === 'battle' && (
        <div className="battle-container">
          <div className="battle-header">
            <div className={`turn-ind ${isMyTurn?'my':'wait'}`}>
              {isMyTurn ? 'üéØ Your Turn!' : '‚è≥ Opponent\'s Turn'}
            </div>
            {turnNotice && (
              <div className={`turn-notice ${turnNotice.type}`}>
                {turnNotice.type === 'hit' ? `üí• Hit!${turnNotice.ship ? ` ${turnNotice.ship} sunk!` : ''}` : 'üí® Miss!'}
              </div>
            )}
          </div>
          <div className="grids">
            <div className="grid-section">
              <div className="grid-title">üéØ Enemy Waters</div>
              {renderGrid(false, isHost?player2:player1, false, isHost?player1.tracking:player2.tracking)}
            </div>
            <div className="grid-section">
              <div className="grid-title">‚öì Your Fleet</div>
              {renderGrid(true, isHost?player1:player2)}
              <div className="ships-status">
                {SHIPS.map((s,i)=>{
                  const ships = isHost?player1.ships:player2.ships;
                  return <div key={i} className={`ship-stat ${ships[i]?.sunk?'sunk':''}`}>{s.name}</div>;
                })}
              </div>
            </div>
          </div>
          <div className="weapons-panel">
            <div className="weapons-title">‚öîÔ∏è Weapons</div>
            <div className="weapons-grid">
              {Object.entries(WEAPONS).map(([k,w])=>{
                const weaps = isHost?player1.weapons:player2.weapons;
                return (
                  <button key={k} className={`weapon-btn ${selectedWeapon===k?'selected':''}`} onClick={()=>setSelectedWeapon(k)} disabled={(k!=='simple'&&weaps[k]<=0)||!isMyTurn||showFiringAnimation}>
                    <span className="weapon-icon">{w.icon}</span>
                    <span className="weapon-name">{w.name}</span>
                    <span className="weapon-count">{k==='simple'?'‚àû':weaps[k]}</span>
                  </button>
                );
              })}
            </div>
          </div>
        </div>
      )}

      {/* QUESTION */}
      {gamePhase === 'question' && currentQuestion && (
        <div className="question-overlay">
          <div className="question-modal">
            {isWatchingQuestion ? (
              <>
                <div className="watching-ind">üëÄ Opponent answering...</div>
              </>
            ) : (
              <div className={`shot-result ${shotResults.some(r=>r.result==='hit')?'hit':''}`}>
                <div className="shot-result-text">{shotResults.some(r=>r.result==='hit')?'üí• HIT!':'üí® MISS!'}</div>
                {sunkShip && <div className="sunk-ann">üö¢ You sunk {sunkShip}!</div>}
                {extraTurn && <div className="extra-notice">‚ö° Correct = another turn!</div>}
              </div>
            )}
            <div className="q-header">üìö Grammar ({difficulty})</div>
            <div className="q-text">{currentQuestion.q}</div>
            <div className="options">
              {currentQuestion.options.map((opt,i)=>(
                <button key={i} className={`opt-btn ${selectedAnswer===i?'selected':''} ${answerResult!==null&&i===currentQuestion.answer?'correct':''} ${answerResult===false&&selectedAnswer===i?'incorrect':''}`} onClick={()=>handleAnswer(i)} disabled={selectedAnswer!==null||isWatchingQuestion}>
                  {opt}
                </button>
              ))}
            </div>
            {answerResult!==null && <div className={`feedback ${answerResult?'correct':'incorrect'}`}>{answerResult?'‚úì Correct!':'‚úó Try again!'}</div>}
          </div>
        </div>
      )}

      {/* GAME OVER */}
      {gamePhase === 'gameover' && (
        <div className="gameover-overlay">
          <div className="gameover-content">
            <div className="gameover-title">üèÜ Game Over! üèÜ</div>
            <div style={{color:'#00d9ff',fontSize:'1.8rem',marginBottom:'25px'}}>{winner===(isHost?1:2)?'You Win!':'You Lose!'}</div>
            <button className="gameover-btn" onClick={()=>window.location.reload()}>Play Again</button>
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.render(<BattleshipESL />, document.getElementById('root'));
  </script>
</body>
</html>
